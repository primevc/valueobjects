package primevc.tools.valueobjects.output;
 import primevc.tools.valueobjects.VODefinition;
  using primevc.utils.TypeUtil;

class ScalaTypeMap implements CodeGenerator
{
	public var map : IntHash<String>;

	public function new() {
		map = new IntHash();
	}

	public function genClass(def : ClassDef) {
		if (!def.isMixin)
			map.set(def.index, def.fullName.substr() + "VO");
	}

	public function genEnum(def:EnumDef) {}

	public function newModule(module:Module) {
		module.generateWith(this);
		return cast this;
	}
}

class ScalaUtil
{
	static function bitmask(numBits:Int, offset:Int=0)
	{
		var mask = 0;
		for (bit in 0 ... numBits) {
			mask |= 1 << (bit + offset);
		}
		return "0x" + StringTools.hex(mask, 4);
	}

	static function propertyName(p:Property) return quote(p.name)
	static public function quote(name:String) return switch (name) {
		case "abstract": "`abstract`";
		case "type": "`type`";
		default: name;
	}

	static function getType(t:PType, ?surroundWithType:String) : {name:String, defaultValue:Dynamic}
	{
		var res = {name:null, defaultValue: null};
		res.name = (surroundWithType != null? surroundWithType + "[" : "") +
		  (switch(t) {
			case Tarray(innerT,_,_):	"IndexedSeq["+ getType(innerT).name +"]";
			case Turi, Turl:			"prime.valuetype.URI";
			case TuniqueID:				"prime.valuetype.ObjectId";
			case TfileRef:				"prime.valuetype.FileRef";
			case Tstring:				"String";
			case Tinteger(_,_,_):		"Int";
			case Tdecimal(_,_,_):		"Double";
			case Tbool(v):				res.defaultValue = v; "Boolean";
			case TenumConverter(_):		throw t; //"";
			case Temail:				"prime.valuetype.InternetAddress";
			case Tdate:					"prime.valuetype.Date";
			case Tdatetime:				"prime.valuetype.DateTime";
			case Tinterval:				"prime.valuetype.Interval";
			case Tcolor:				"prime.valuetype.RGBA";
			case TclassRef(className):	className;

			case Tdef(ptypedef): switch (ptypedef) {
				case Tclass		(def):	def.fullName + "VO";
				case Tenum		(def):	def.fullName + ".EValue";
			};
		  }) + (surroundWithType != null? "]" : "");

		return res;
	}
}
using ScalaUtil;

class Scala implements CodeGenerator
{
	public static function generate() {
		Module.root.generateWith(new Scala(Module.root));

		var filename = "ValueObjects.scala";
		trace("WRITING: "+filename);
		var file = neko.io.File.write(filename, false);
		file.writeString(
"// GENERATED BY VOCompiler - MODIFICATIONS WILL BE LOST

import prime.vo._;
import prime.vo.source._;
import prime.vo.definition._;
import prime.vo.valuetype.Conversion;

");

		for (m in Module.pkgRoots)
		{
			var map = new ScalaTypeMap();
			m.generateWith(map);
			file.writeString("
package "+ m.fullName +".mutable {
  object VO { val typeMap : scala.collection.immutable.IntMap[prime.vo.mutable.VOCompanion[_]] = scala.collection.immutable.IntMap(");
			var first = true;
			for (index in map.map.keys()) {
				if (first) first = false;
				else file.writeString(",");
				file.writeString("\n    " + index + " -> " + map.map.get(index));
			}

file.writeString("
  )}
}
");
		}
		for (m in writelist) m.write(file);
		file.close();
		MutableScala.generate();
	}
}

class MutableScala implements CodeGenerator
{
	private static var writelist = new List<MutableScala>();

	public static function generate() {
		Module.root.generateWith(new MutableScala(Module.root));

		var filename = "MutableValueObjects.scala";
		trace("WRITING: "+filename);
		var file = neko.io.File.write(filename, false);
		file.writeString(
"// GENERATED BY VOCompiler - MODIFICATIONS WILL BE LOST

import scala.collection.JavaConversions
import scala.xml.NodeSeq
import prime.types._
import prime.utils._
import prime.utils.msgpack._
import prime.vo.mutable._

");

		for (m in Module.pkgRoots)
		{
			var map = new ScalaTypeMap();
			m.generateWith(map);
			file.writeString("
package "+ m.fullName +".mutable {
  object VO { val typeMap : scala.collection.immutable.IntMap[prime.vo.mutable.VOCompanion[_]] = scala.collection.immutable.IntMap(");
			var first = true;
			for (index in map.map.keys()) {
				if (first) first = false;
				else file.writeString(",");
				file.writeString("\n    " + index + " -> " + map.map.get(index));
			}

file.writeString("
  )}
}
");
		}
		for (m in writelist) m.write(file);
		file.close();
	}
	
	private function new(m:Module) {
		this.mod = m;
		this.code = new StringBuf();
		writelist.add(this);
	}
	
	function write(file:neko.io.FileOutput)
	{
		if (!shouldWrite) return;
		
		file.writeString("\n\npackage ");
		file.writeString(this.mod.fullName);
		
		file.writeString("\n{\n\n");
		file.writeString(code.toString());
		file.writeString("\n\n} // end ");
		file.writeString(this.mod.fullName);
	}
	
	var mod			: Module;
	var code		: StringBuf;
	var dir			: String;
	var shouldWrite : Bool;
	
	var currentFieldBitNum : Int;
	
	public function newModule	(m:Module)		: CodeGenerator
	{
		trace("\n- Scala module: "+m.fullName);
		return new Scala(m);
	}
	
	inline function a(str) code.add(str)
	inline function ac(ch) code.addChar(ch)
	
	
	
	public function genClass	(def:ClassDef)	: Void
	{
		shouldWrite = true;
		
		trace("  - Scala class:  "+def.name);
		
	// --- VO class definition
		var thisPropsStartIndex = null, idType:String = null, idFromSuperclassOrTrait = false, idProperty:Property = null, 
			nonEmptyChecks = 0, emptyChecks = new List<{expr:String, id:Int}>();
		
		var hasSubtypes = false;
		var subtypes : List<ClassDef> = new List();
		for (imp in def.implementedBy) if (cast(imp, ClassDef).extendsType(def)) {
			subtypes.add(cast imp);
			hasSubtypes = true;
		}
		
		var superClassHasBitflags = false;
		var fullName = def.fullName;
		// Check if this is a NamedSetDef
		var ns:NamedSetDef = Std.is(def, NamedSetDef)? cast def : null;
		
		for (i in 0 ... def.propertiesSorted.length)
		{
			var p = def.propertiesSorted[i];
			
			if (thisPropsStartIndex == null && !Util.isDefinedInSuperClassOf(def, p))
				thisPropsStartIndex = i;
			
			// Check if empty_? needs to be overridden
			if (!Util.isDefinedInSuperClassOf(def, p)) switch (p.type)
			{
				case Tdef(cl): switch (cl) {
					case Tclass(cl):	emptyChecks.add({expr: "(__"+ p.name +" == null || __"+ p.name + ".empty_?)", id: i});
					case Tenum(e):		emptyChecks.add({expr: "(__"+ p.name +" == null || __"+ p.name + ".toString.isEmpty)", id: i});
				}
				
				case Tarray(_,_,_):
					emptyChecks.add({expr: "(__"+ p.name +" == null || __"+ p.name +".length == 0)", id: i});
				
				case Tstring, TfileRef, Tdate, Tdatetime, Tinterval, Tcolor, Temail, Turi, Turl, TuniqueID, Tinteger(_,_,_), Tdecimal(_,_,_), Tbool(_):
					++nonEmptyChecks;
				
				case TenumConverter(_):		throw p;
				case TclassRef(_):			continue; //throw p;
			}
			else switch (p.type) {
				case TfileRef, Tdate, Tdatetime, Tinterval, Tcolor, Temail, Turi, Turl, TuniqueID, Tinteger(_,_,_), Tdecimal(_,_,_), Tbool(_):
					superClassHasBitflags = true;
				default:
			}
			
			if (p.hasOption(unique))
			{
				if (idProperty != null) throw "VO's may have only 1 ID property...\n  idProperty = "+idProperty+"\n"+def;
				idProperty = p;
				idType = getType(p.type).name;
				Assert.notNull(idType);
				
				if (p.definedIn != def)
					idFromSuperclassOrTrait = true;
			}
		}
		
		a("\n\n//---\n\nsealed trait "); a(def.name); a(" extends ");
		// extra stuff
		if (ns != null)
		{
			if (ns.keys.length > 0) {
			//	a("scala.collection.mutable.HashSet[");
			//	a(getType(ns.baseType).name);
				a("prime.vo.mutable.NamedSet["); a(getType(ns.baseType).name); // a("] with ");
			//	a("scala.collection.mutable.SetLike["); a(getType(ns.baseType).name); a(", "); a(def.name); a("VO");
			}
			else {
				a("ValueObject"); if (idType != null) a("WithID");
				a(" with scala.collection.Traversable[");
				a(getType(ns.baseType).name);
			}
			a("]");
		}
		else if (def.superClass != null) {
			a(def.superClass.fullName);
			if (!def.superClass.hasUniqueID() && idType != null) {
				// Superclass has no Unique ID. Add the required trait now.
				a(" with ValueObjectWithID");
			}
		}
		else {
			a("ValueObject"); if (idType != null) a("WithID");
		}
		
		
		//TODO: Generate traits for supertypes ?
		for (t in def.supertypes) if (Std.is(t, MagicClassDef) || def.superClass != t) {
			 a("\n with "); a(t.fullName);
		}
		
		a("\n{");
		
		// properties
		var requiredProps = new List<Int>();
		currentFieldBitNum = thisPropsStartIndex;
		
		for (p in def.propertiesDefined)
		//	if (!p.isTransient())
				writeVarGetter(p);
		a("\n}\n\n");
		
		if (def.isMixin) {
			genCompanion(def, idProperty, ns, thisPropsStartIndex, hasSubtypes, subtypes);
			return;
		}
		
		// -- end trait
		//
		// VO Class
		
		a("\n\nsealed class "); a(def.name); a("VO");
		
		if (idType != null) {
			a(def.superClass != null && def.superClass.hasUniqueID()? " (_id:" : " (val _id:"); a(idType); a(")");
		}
		a(" extends ");
		
		if (def.superClass != null) {
			a(def.superClass.fullName); a("VO");
			if (idType != null && def.superClass.hasUniqueID()) a("(_id)");
			a(" with ");
		}
		else if (!def.isMixin && ns == null) {
			a("AbstractValueObject with ");
		}

		a(def.name); a("\n{");
		
		for (i in thisPropsStartIndex ... def.propertiesSorted.length) {
			var p = def.propertiesSorted[i];
		//	if (p.isTransient())
		//		continue;
			var r = p.hasOption(required);
			if (r) requiredProps.add(i);
			writeSetter(i, p);
		}
		
		
		
		// IDType
		if(idType != null) {
			if (!idFromSuperclassOrTrait) {
				a("\n  type IDType = "); a(idType);
			}
			a("\n  def this()  = this("); a(nilValue(idProperty.type)); a(")");
		}
		
		// Companion getter
		a("\n  override def Companion : VOCompanion[_] with VOMessagePacker[_] = "); a(def.name); a("VO");
		
/*		// partial_?
		if (def.propertiesSorted.length != 0) {
			a("\n  override def partial_? = numFieldsSet_? != "); a(Std.string(def.propertiesSorted.length));
		}
*/		
		// Non-bitflag empty checks overrides
		if (emptyChecks.length > 0)
		{
			var andAnd;
			
			// updateFieldsSet_!
			a("\n  override def updateFieldsSet_! = {");
			if (def.superClass != null || nonEmptyChecks != 0) {
				a("\n    super.updateFieldsSet_!;");
			}
			for (check in emptyChecks) {
				a("\n    if (!"); a(check.expr); a(") $fieldsSet |= 0x"); a(StringTools.hex(1 << def.propertiesSorted[check.id].bitIndex())); a(";");
			}
			a("\n  }");
			
			// fieldIsSet_?
			a("\n  override def fieldIsSet_?(index:Int) = index match {");
			for (check in emptyChecks) {
				a("\n    case " + def.propertiesSorted[check.id].bitIndex()); a(" => !"); a(check.expr);
			}
		 	a("\n    case _ => super.fieldIsSet_?(index)");
			a("\n  }");
		}
		
		
		// validation
		if (requiredProps.length != 0)
		{
			a("\n  override def validationErrors_? = {\n    var errors : List[(Symbol,String)] = Nil");
			for (i in requiredProps)
			{
				a("\n    if (!fieldIsSet_?("); a(Std.string(i)); a(")) errors ::= ('"); a(def.propertiesSorted[i].name); a(', "error.required")');
			}
			a("\n    errors\n  }\n");
		}
		
		// extra stuff
		if (Std.is(def, NamedSetDef))
			genNamedSetDefMethods(cast def);
		
		a("\n}\n\n");
		
	// --- End VO class
		genCompanion(def, idProperty, ns, thisPropsStartIndex, hasSubtypes, subtypes);
	}
	
	private function genCompanion(def:ClassDef, idProperty:Property, ns, thisPropsStartIndex, hasSubtypes, subtypes:List<ClassDef>)
	{
		// VO MessagePacker object
		a("object "); a(def.name);
		
		if (def.isMixin)
		{
			a(" extends VOMessagePacker["); a(def.name); a("]\n{");
			
			// MessagePack serialization
			new ScalaMessagePacking(code, def).genSerialization();
			
			a("}\n\n");
			return;
		}
		
		// ---
		// Regular VO class Companion
		// ---
		a("VO extends VOCompanion["); a(def.name); a("VO"); a("] with VOMessagePacker["); a(def.name); a("]");
		
		if (idProperty != null) {
			a(" with "); a(def.name); a("IDAccessor");
		}
		a("\n{");
		
		// MessagePack serialization
		new ScalaMessagePacking(code, def).genSerialization();
		
		a("\n  override def empty: "); a(def.name); a("VO = new "); a(def.name); a("VO;\n");
		
		// afasjfakjfhaf
		if (ns != null && ns.keys.length > 0)
		{
//			a("\n  override def getValue(vo:"); a(def.name); a("VO, key:String): AnyRef = vo.get(key)");
			a("\n  override def putValue(vo:"); a(def.name); a("VO, key:String, value:AnyRef): "); a(def.name); a("VO = { vo.addEntry(ConvertTo.vo["); a(getType(ns.baseType).name); a("](value)); vo; }");
//			a("\n  override def fieldsSetNames(vo:"); a(def.name); a("VO) = vo.keySet");
		}
		
		// field()
		if (thisPropsStartIndex != null)
		{
			for (i in 0 ... def.propertiesSorted.length)
			{
				var p = def.propertiesSorted[i];
				a("\n  val "); a(quote(p.name));
				if (p.parent == def)
				{
				 	a(" = Field('"); a(p.name); a(", ");
					addFieldTypeConstructor(p.type, p.hasOption(reference));
					if (p.hasOption(required)) {
						a(", required = true");
					}
					a(")");
				}	
				else {
					a(" = "); a(p.parent.fullName); a("VO."); a(quote(p.name));
				}
			}
			
			// fields : Array
			a("\n\n  override val fields = Array[Field](");
			for (i in 0 ... def.propertiesSorted.length)
			{
				var p = def.propertiesSorted[i];
				if (i != 0) a(", "); a(quote(p.name));
			}
			a(");");
			
			// field(Int)
			a("\n\n  override def field(index: Int) = index match {");
			for (i in 0 ... def.propertiesSorted.length)
			{
				var p = def.propertiesSorted[i];
				a("\n    case "+ p.bitIndex()); a(" => this."); a(quote(p.name));
			}
			a("\n    case _ => super.field(index)");
			a("\n  }");
			
			// field(String)
			a("\n\n  override def field(key: String) = key match {");
			for (i in 0 ... def.propertiesSorted.length)
			{
				var p = def.propertiesSorted[i];
				a('\n    case "'); if (p.hasOption(unique)) a('_id" | "');  a(p.name); a('" => '+ p.bitIndex());
			}
			a("\n    case _ => super.field(key)");
			a("\n  }");
		}
		
		if (def.propertiesSorted.length == 0)
		{
			a("\n  def getValue(vo:"); a(def.name); a("VO, index:Int) : AnyRef = null");
			a("\n  def putValue(vo:"); a(def.name); a("VO, index:Int, value:AnyRef) : "); a(def.name); a("VO = vo\n");
		}
		else
		{
			// getValue()
			a("\n\n  def getValue(vo:"); a(def.name); a("VO, index:Int) : AnyRef = ");
			if (def.superClass != null && thisPropsStartIndex == null) {
				a(def.superClass.fullName); a("VO.getValue(vo, index);\n");
			}
			else
			{
				a("(index match {\n");
				for (i in 0 ... def.propertiesSorted.length) {
					var p = def.propertiesSorted[i];
					a('    case ' + p.bitIndex()); a(' => vo.'); a(propertyName(p)); a('\n');
				}
				a("    case _ => null\n  }).asInstanceOf[AnyRef]\n\n");
			}

			// putValue(vo, index:Int, value)
			a("  def putValue(vo:"); a(def.name); a("VO, index:Int, value:AnyRef) : "); a(def.name); a("VO = ");
			if (def.superClass != null && thisPropsStartIndex == null) {
				a(def.superClass.fullName); a("VO.putValue(vo, index, value).asInstanceOf["); a(def.name); a("VO];\n");
			}
			else
			{
				a("{ index match {\n");
				for (i in 0 ... def.propertiesSorted.length) {
					var p = def.propertiesSorted[i];
					a('    case ' + p.bitIndex()); a(' => vo.'); a(p.name); a("_("); a("value );\n");
				}
				a("  }; vo; }\n");
			}
		}
		
		a("}\n\n");
		
		// VOAccessor
		a("trait "); a(def.name); a("VOAccessor //extends VOAccessor["); a(def.name); a("VO]\n{\n");
			// _fields
			a("  def field    (vo: "); a(def.name); a("VO, key:String) : Int    = "); a(def.name); a("VO.field(key);\n");
			a("  def field    (vo: "); a(def.name); a("VO, index: Int) : Field  = "); a(def.name); a("VO.field(index);\n");
			a("  def fieldsFor(vo: "); a(def.name); a("VO) : IndexedSeq[Field]  = "); a(def.name); a("VO.fields;\n");
			a("  def isSet    (vo: "); a(def.name); a("VO, key:String): Boolean = vo.fieldIsSet_?(field(vo, key));\n");
			
			a("  def getValue (vo: "); a(def.name); a("VO, key:String) : AnyRef = "); a(def.name); a("VO.getValue(vo, key)\n");
			a("  def putValue (vo: "); a(def.name); a("VO, key:String, value:AnyRef) : "); a(def.name); a("VO = "); a(def.name); a("VO.putValue(vo, key, value)\n");
		a("}\n");	
		
		// IDAccessor & VOProxy
		if (idProperty != null)
		{
			var idType = getType(idProperty.type).name;
			
			a("trait "); a(def.name); a("IDAccessor extends IDAccessor["); a(def.name); a("VO] {\n");
				a("  val idField = " ); a(idProperty.definedIn.fullName); a("VO."); a(idProperty.name); a('\n');
				a("  def idValue(vo:"); a(def.name); a("VO): "); a(idType); a(" = if(vo == null) "); a(nilValue(idProperty.type)); a(" else vo."); a(idProperty.name); ac("\n".code);
				a("  def idValue(vo:"); a(def.name); a("VO, idValueToSet:"); a(idType); a(") = { vo."); a(idProperty.name); a(" = idValueToSet; }\n");
			a("}\n");
			// VOFieldInfo
			a("trait "); a(def.name); a("FieldInfo extends VOFieldInfo {\n");
//				a('  override val numFields = '); a(def.name); a('VO.numFields;\n');
				a("  override def field(index: Int): Field = "); a(def.name); a('VO.field(index);\n');
				a("  override def field(key: String): Int = " ); a(def.name); a('VO.field(key);\n');
			a("}\n");
			a("trait "); a(def.name); a("VOProxy extends "); a(def.name); a("IDAccessor with "); /*a(def.name); a("VOAccessor with ");*/ a(def.name); a("FieldInfo\n");
		}
		
		// XML mapping
		genXMLComponent(def, idProperty);
		
//		if (def.options.length > 0)
//			trace(def.options.first().toString());
	}
	
	
	private function genSerialization(def:ClassDef)
	{	
		new ScalaMessagePacking(code, def).genSerialization();
	}
	
	
	function addPropnameCase(p:Property) {
		a('      case "'); a(p.name); a('" => ');
	}
	function addVOGetterCase(p:Property) {
		addPropnameCase(p); a('vo.'); a(quote(p.name));
	}
	
	function writeLiteral(type:PType, val:Dynamic) switch (type)
	{
		case Tbool(_), Tinteger(_,_,_), Tdecimal(_,_,_):
			a(Std.string(val));
		
		case TfileRef:
			ac('"'.code); a(Std.string(val)); ac('"'.code);
		
		case Tstring:
			ac('"'.code); a(Std.string(val)); ac('"'.code);
		
		case Turi, Turl:
			ac('"'.code); a(Std.string(val)); ac('"'.code);
		
		case Tdate, Tdatetime, TuniqueID, Temail:
			ac('"'.code); a(Std.string(val)); ac('"'.code);
		
		case Tcolor:
			if (Std.is(val, String)) {
				ac('"'.code); a(Std.string(val)); ac('"'.code);
			}
			else
				StringTools.hex(val, 6);
		
		case TenumConverter(enums):
			throw "Unsupported value literal";
		
		case Tdef(_), Tinterval, Tarray(_,_,_), TclassRef(_):
			throw "Unsupported value literal: "+type;
	}
	
	function getSimpleValue(t:PType, path:String) return switch(t) {
		case Tdef(ptypedef):		switch (ptypedef) {
			case Tenum(def):		path;
			default:				path;
		}
		case Turi, Turl, Temail, TuniqueID, TfileRef, Tdate, Tdatetime:
			'"" + ' + path; //+".toString";
		case Tstring:				path;
		case Tinteger(_,_,_):		path;
		case Tdecimal(_,_,_):		path;
		case Tbool(_):				path;
		case Tcolor:				path;
		
		case Tinterval:				throw t;
		case Tarray(innerT,_,_):	throw t;
		case TenumConverter(prop):	throw t;
		case TclassRef(_):			throw t;
	}
	
	function genNamedSetKeyMatcher(def: NamedSetDef, wildcardMethod:String, action:Int->Property->String)
	{
		if (def.keys.length == 1)
		{
			var k = def.keys[0];
			a(getSimpleValue(k.prop.type, "item." + k.path)); a(" match {");
			
			for (i in 0 ... def.propertiesSorted.length)
			{
				var p = def.propertiesSorted[i];
				a("\n    case "); writeLiteral(k.prop.type, def.getValueByPath(p.defaultValue, k.path)); a(" => "); a(action(i,p));
			}
		}
		else
		{
			a("(");
			for (i in 0 ... def.keys.length) {
				var k = def.keys[i];
				a(getSimpleValue(k.prop.type, "item." + k.path));
				if (i+1 != def.keys.length) a(", ");
			}
			a(") match {");
			
			for (i in 0 ... def.propertiesSorted.length)
			{
				var p = def.propertiesSorted[i];
				a("\n    case (");
				
				var firstKey = true;
				for (k in def.keys)
				{
					if (!firstKey) a(", ");
					else firstKey = false;
					
					writeLiteral(k.prop.type, def.getValueByPath(p.defaultValue, k.path));
				}
				
				a(") => "); a(action(i,p));
			}
		}
		a("\n    case _ => "); a(wildcardMethod); a("(item)\n");
	}
	
	function genNamedSetDefMethods(def: NamedSetDef)
	{
		var type = getType(def.baseType);
		
		a("\n  override def foreach[U](f: "); a(type.name); a(" => U) {");
		for (i in 0 ... def.propertiesSorted.length) {
			var p = def.propertiesSorted[i];
			a("\n    if (__"); a(p.name); a(" != null && fieldIsSet_?("); a(p.bitIndex() +")) f(__"); a(p.name); a(");");
		}
		if (def.keys.length > 0)
			a("\n    super.foreach(f);");
		a("\n  }\n");
		
		if (def.keys.length == 0) return; // No keys, no way to map...
		
//		a("\n  def this$ = "); a(def.name); a("VO.asInstanceOf[VOCompanion[org.valueobjects.traits.NamedSet["); a(type.name); a("]]];");
		a("\n  override def clear() { "); a(def.name); a("VO.clear(this); super.clear(); }\n");
		a("\n  override def empty: "); a(def.name); a("VO = new "); a(def.name); a("VO;\n");
//		a("\n  override def clone(): this.type = new "); a(def.name); a("VO ++= this;\n");
//		a("\n  override def companion() = "); a(def.name); a("VO;\n");
		
		
		var cl:ClassDef = switch (def.baseType)
		{
			case Tdef(tdef): switch(tdef) {
				case Tclass(cl): cl;
				default: null;
			}				
			default: null;
		}
		if (cl == null) throw def; // Not a set of VO's, so we're done.
		
		a("\n  final override def containsEntry(item:"); a(type.name); a(") = ");
		genNamedSetKeyMatcher(def, "super.containsEntry", function(i,p) return "__"+ p.name +" != null && fieldIsSet_?("+ p.bitIndex() +");");
		a("  }\n");
		
		a("\n  final override def addEntry(item:"); a(type.name); a(") = {");
		genNamedSetKeyMatcher(def, "super.addEntry", function(i,p) return "this."+quote(p.name)+" = item;");
		a("  }; true; }\n");
		
		a("\n  final override def removeEntry(item:"); a(type.name); a(") = ");
		genNamedSetKeyMatcher(def, "super.removeEntry", function(i,p) return "val old = __"+ p.name +"; if (old != null && fieldIsSet_?("+ p.bitIndex() +")) Some(old) else None;");
		a("  }\n");
		
		a("}\n");
		
		a("\ntrait "); a(def.name); a("VOXMLComponent extends XMLComponent\n{");
		a("\n  this: "); a(cl.fullName); a("VOXMLComponent =>\n");
		
		a('\n  def setValueObject(valueobject: '); a(def.name); a('VO, xml: NodeSeq) : '); a(def.name); a('VO = ');
		a("\n  {");
		a("\n    val vo = if (valueobject != null) valueobject else new "); a(def.name); a("VO;");
		a("\n    for (xml <- xml) for (node <- xml.child) if (node.isInstanceOf[scala.xml.Elem]) vo.add(setValueObject(new "); a(cl.fullName); a("VO, node));");
		a("\n    vo");
		a("\n  }");
		
		a("\n  def toXML(vo:"); a(def.name); a("VO): NodeSeq = if (vo.empty_?) NodeSeq.Empty else vo.toSeq.flatMap(toXML(_));\n");
		
/*		a("\n  override def get(key: String): Option["); a(type.name); a("] = {");
		for (i in 0 ... def.propertiesSorted)
		{
			var p = def.propertiesSorted[i];
			
			a("\n    if (fieldIsSet_?("+i+")) "); a("this."); a(quote(p.name));
		}
		a("\n    ");
		
/*		
		To implement a concrete map, you need to provide implementations of the following methods:
		      def get(key: A): Option[B]
		      def iterator: Iterator[(A, B)]
		      def + [B1 >: B](kv: (A, B1)): This
		      def -(key: A): This

		If you wish that methods like take, drop, filter also return the same kind of map you should also override:
		      def empty: This

		It is also good idea to override methods foreach and size for efficiency.
		
		a("\n  def get(key: String): Option["); a(type); a("] = ");
		a("\n  def iterator: Iterator[(String, "); a(type); a(")] = ");
		a("\n  def + [B1 >: B](kv: (A, B1)): This = ");
		a("\n  def -(key: A): This = ");
*/	}
	
	static public function addComponentDependencies(code:StringBuf, dependencies:Hash<Bool>, suffix:String)
	{
		var a = code.add;
		var first = true;
		
		for (clname in dependencies.keys())
		{
			a("\n  ");
			if (first) {
				first = false;
				a("this: ");
			}
			else {
				a("with  ");
			}
			a(clname); a(suffix);
		}
		if (!first) a(" =>\n");
	}
	
	function addLowerCaseFirst(str:String)
	{
		code.addChar(str.charAt(0).toLowerCase().charCodeAt(0));
		code.addSub(str, 1);
	}
	
	function className(t:PType) return Util.unpackPTypedef(Util.getPTypedef(t)).fullName
	
	function writeVarGetter(p:Property)
	{
		a("\n  ");
		
		var propName = propertyName(p);
		
		// Storage
		a("/*@field*/ protected[this] var __"); a(p.name); a(": ");
		var tdef = getPropertyTypename(p);
		a(tdef.name);
		a(" = "); a((tdef.defaultValue != null)? tdef.defaultValue : nilValue(p.type));
		
		// Getter
		a("\n  final def "); a(propName); a(" : "); a(tdef.name); a(" = ");
		switch (p.type)
		{
			case Tdef(cl): switch (cl) {
				case Tclass(cl):
					var vo = cl.fullName + "VO";
					add_ifVarNotNull(p.name, (!p.hasOption(reference))? "new " + vo : "new Ref[" + vo +"](null)");
				
				case Tenum(e):
					add_ifVarNotNull(p.name, e.fullName + ".Null");
			}
			
			case Tarray(innerT,_,_):
				add_ifVarNotNull(p.name, (p.hasOption(reference)? "RefArray[" : "Array[") + getType(innerT).name +"]()");
			
			case Tstring:
				add_ifVarNotNull(p.name, '""');
			
			case Tdate, Tdatetime, Tinterval, Tcolor, Temail, Turi, Turl, TuniqueID, TfileRef, Tinteger(_,_,_), Tdecimal(_,_,_), Tbool(_):
				a('__'); a(p.name);
			
			case TclassRef(className):	a(className); //throw p;
			case TenumConverter(_):		throw p;
		}
		
		// optional hasProperty()
		if (p.hasOption(optional)) {
			a("\n  final def has"); a(p.name.substr(0,1).toUpperCase()); a(p.name.substr(1)); a("_? = fieldIsSet_?("); a(p.bitIndex() + ")");
		}
	}
	
	function writeSetter(i:Int, p:Property)
	{
		var tdef = getPropertyTypename(p);
		var bit = (1 << this.currentFieldBitNum);
		
		// Setter
		a("\n  final def "); a(p.name); a("_=(v:"); a(tdef.name); a(") : Unit = { ");
		
		switch (p.type) {
			case Tdef(_), Tarray(_,_,_): // Don't set any bits
			default:
				var nilChecked = false;
				if (nilValue(p.type) == "null")
				{
					nilChecked = true;
					a("if (");
					if (p.type == Tstring) a("!v.isEmpty");
					else {
						a("v != "); a(nilValue(p.type));
					}
				 	a(") ");
				}
				a("$fieldsSet |= 0x"); a(StringTools.hex(1 << p.bitIndex()));
				if (nilChecked) {
					a("; else $fieldsSet &= ~0x"); a(StringTools.hex(1 << p.bitIndex()));
				}
				a("; ");
		}
		a("__"); a(p.name); a(" = v } ");
		
		if (p.hasOption(reference))
		{
			var clname = getType(p.type).name;
			a("\n  final def "); a(p.name); a("_=(v:"); a(clname); a(") : Unit = this."); a(quote(p.name));
			switch (p.type) {
				case Tarray(innerType, _,_):
					var innerName = getType(innerType).name;
					a(" = new RefArray["); a(innerName); a("](v.map("); a(innerName); a(".idValue(_)).toArray, v)");
				default:
					a(" = new Ref["); a(clname); a("]("); a(clname); a(".idValue(v), v)");
			}
			a("\n  final def "); a(p.name); a("_(v:AnyRef) : Unit = ");
			a(quote(p.name));
			a(" = ");
			a(convertFromAnyRefTo(p.type, p.hasOption(reference)));
			a("(v);\n");
		}
		else
		{
			a("\n  final def "); a(p.name); a("_(v:AnyRef) : Unit = { val __value");
			if (Util.isEnum(p.type)) { a(": "); a(getType(p.type).name); }
			a(" = "); a(convertFromAnyRefTo(p.type));
//			if (Util.isEnum(p.type))
//				a("(v.toString).getOrElse(null);");
//			else
				a("(v);");
			
			a(" "); a(quote(p.name)); a(" = __value;");
			switch (p.type) {
				case Tdef(_), Tarray(_,_,_): // Don't set any bits
				default:
					a(" if (v == null) "); a("$fieldsSet &= ~0x" + StringTools.hex(1 << p.bitIndex())); //nilValue(p.type)); ac(")".code);
			}
			a(" }\n");
		}
		
		// Bit number of next flag
		++this.currentFieldBitNum;
	}
	
	function addClassProxy(clname:String, valSuffix:String = "Proxy")
	{
		addLowerCaseFirst(clname.substr(mod.fullName.length + 1).split('.').join('_')); a(valSuffix); a(": VOProxy["); a(clname); a("VO]");
	}
	
	function add_ifVarNotNull(name:String, defaultValue:String)
	{
		a("{ if (__"); a(name); a(" == null) __"); a(name); a(" = "); a(defaultValue); a("; __"); a(name); a(" }");
	}
	
	function commaNewline(comma = true) {
		if (comma) ac(','.code);
		ac('\n'.code);
	}
	
	function addFieldTypeConstructor(t:PType, isRef:Bool) : Void
	{
		a("Type.");
		switch(t)
		{
			case Tdef(cl): switch (cl) {
				case Tclass(cl):	a("Tdef("); a(cl.fullName); a("VO, "); a(Std.string(isRef)); a(")");
				case Tenum(e):		a("Tenum("); a(e.fullName); ac(")".code);
			}
			case Tbool(v):			a("Tbool("); a(Std.string(v)); ac(")".code);
			
			case Tinteger(l,u,s):
				a("Tinteger(");
				if (l != null){											a("min = "); a(Std.string(l)); }
				if (u != null){ if (l != null)				a(", ");	a("max = "); a(Std.string(u)); }
				if (s != null){ if (u != null || l != null)	a(", ");	a("stride = "); a(Std.string(s)); }
				ac(")".code);
			
			case Tdecimal(l,u,s):
				a("Tdecimal(");
				if (l != null){											a("min = "); a(Std.string(l)); }
				if (u != null){ if (l != null)				a(", ");	a("max = "); a(Std.string(u)); }
				if (s != null){ if (u != null || l != null)	a(", ");	a("stride = "); a(Std.string(s)); }
				ac(")".code);
			
			case Tarray(t,l,u):
				a("Tarray("); addFieldTypeConstructor(t,isRef);
				if (l != null || u != null) a(', ');
				if (l != null){							a("min = "); a(Std.string(l)); }
				if (u != null){ if (l != null) a(", ");	a("max = "); a(Std.string(u)); }
				ac(")".code);
			
			default:
				a(Std.string(t));
		}
	}
	
	static public function convertFromAnyRefTo(t:PType, ref = false) return switch(t) {
		case Tdef(ptypedef):		switch (ptypedef) {
			case Tenum(def):		def.fullName+".convert";
			default:				"ConvertTo." + (ref? "voRef" : "vo") + "["+ getType(t).name + "]";
		}
		case Tarray(innerT,_,_):	switch (innerT) {
			case Tdef(_):			"ConvertTo.voArray["+getType(innerT).name+"]";
			default:				"ConvertTo.array["+getType(innerT).name+"]";
		}
		case Turi, Turl:			"ConvertTo.uri";
		case Temail:				"ConvertTo.email";
		case Tinterval:				"ConvertTo.interval";
		case TuniqueID:				"ConvertTo.uniqueID";
		case TfileRef:				"ConvertTo.fileRef";
		case Tstring:				"ConvertTo.string";
		case Tinteger(_,_,_):		"ConvertTo.integer";
		case Tdecimal(_,_,_):		"ConvertTo.decimal";
		case Tdate:					"ConvertTo.date";
		case Tdatetime:				"ConvertTo.datetime";
		case Tbool(_):				"ConvertTo.boolean";
		case Tcolor:				"ConvertTo.rgba";
		case TenumConverter(prop):	prop.parent.fullName + ".from" + prop.name.substr(2); //"";
		case TclassRef(className):	"ConvertTo."+className; //throw t;
	}
	
	function arrayInnerType(p:Property) return switch(p.type) {
		case Tarray(innerT,_,_): innerT;
		default: null;
	}
	
	function isRefArray(p:Property) return switch(p.type) {
		case Tarray(_,_,_): p.hasOption(reference);
		default: false;
	}
	
	function getPropertyTypename(p:Property) return switch(p.type)
	{	
		case Tarray(innerT, _, _):
			if (p.hasOption(reference)) {name:"RefArray["+getType(innerT).name+"]", defaultValue: null};
			else getType(p.type);
		
		default:
			var type = getType(p.type);
			if (p.hasOption(reference)) {
			 	type.name = "Ref["+type.name+"]";
			}
			type;
	}
	
	function nilValue(t:PType) return switch(t) {
		case Tstring, Turi, Turl, TuniqueID, Tinterval, Tdate, Tdatetime, Temail, Tdef(_), Tarray(_,_,_), Tcolor, TfileRef:
			"null";
		
		case Tinteger(_,_,_):		"0";
		case Tdecimal(_,_,_):		"Double.NaN";
		case Tbool(v):				Std.string(v);
		
		case TclassRef(_):			"null";
		case TenumConverter(_):		throw t; //"";
	}
	
	public function genEnum	(def:EnumDef)	: Void
	{
		shouldWrite = true;
		
		var a = code.add;
		var addConversionParams = function(withVal) {
			for (prop in def.conversions) if (prop.name != "toString") {
//				Assert.that(prop.type == Tstring, Std.string(def));
				a(", ");
				if (withVal) a("val ");
				a(quote(prop.name)); a(":String"); // a(conv); ac('"'.code);
			}
		}
		
		a("\nobject "); a(def.name); a(" extends Enumeration with Enum {\n  ");
		
		var overrideValueOf = null;
		
		a("class EValue(nextId:Int, name:String, val value:Int");
		addConversionParams(true);
		a(") extends Val(nextId, name);\n  ");
		a("final def V(name:String, value:Int");
		addConversionParams(false);
		a(") = new EValue(nextId, name, value");
		for (prop in def.conversions) if (prop.name != "toString") {
			a(", "); a(quote(prop.name));
		}
		a(");\n");
		
		a("\n  final def fromValue(v: Int) : this.EValue = v match {");
		for (e in def.enumerations) if (e.type == null)
		{
			a("\n    case " + e.intValue); a(" => this."); a(e.name);
		}
		a("\n    case _ => this.Null");
		a("\n  }\n\n");
		
		a('  val Null = V("", -1');
		for (prop in def.conversions) if (prop.name != "toString") a(', ""');
		a(")\n");
		
		for (e in def.enumerations)
		{
			
			if (e.type != null)
			{
				a('  def '); a(e.name); a('(value:'); a(getType(e.type).name); a(') = new EValue(nextId, "'); a(e.name); ac('"'.code); a(", -1");
				for (key in e.conversions.keys()) if (key != "toString") {
					var conv = e.conversions.get(key);
					a(', "'); a(conv); ac('"'.code);
				}
				a(");\n\n");
				
				overrideValueOf = e;
			}
			else {
				a("  val "); a(e.name); a(' = V("'); a(e.name); ac('"'.code); a(", " + e.intValue);
				for (prop in def.conversions) if (prop.name != "toString") {
					var conv = e.conversions.get(prop.name);
					a(', "'); a(conv != null? conv : e.name); ac('"'.code);
				}
				a(")\n");
			}
		}
		
  		for (conv in def.conversions)
		{
			a("\n\n  final def from"); a(conv.name.substr(2)); a("(str:String) : EValue = str match\n  {");
			for (e in conv.enums) if (e != def.catchAll)
			{
				a('\n    case "'); a(e.conversions.get(conv.name)); a('" => this.'); a(e.name); a(";");
			}
			if (overrideValueOf != null) {
				a("\n    case _ => "); a(overrideValueOf.name); a("(str);");
			}
			else if (conv.name != "toString")
				a("\n    case _ => fromString(str);");
			else
			 	a("\n    case _ => Null");
				
			a("\n  }");
		}
		a("\n}\n");
	}
	
	function genXMLComponent(def:ClassDef, idProperty:Property)
	{
		var map = def.getOptionDef(XMLMapping);
		if (map == null) return;
		
		a("trait "); a(def.name);
		a("VOXMLComponent extends XMLComponent\n{");
		
		var g = new XMLProxyGenerator(code, def, map);
		g.genDependencies();
		g.fromXML();
		g.toXML();
//		g.implicits();
		
		if (idProperty != null)
		{
			a("  trait "); a(def.name); a("VOXMLProxy\n   extends XMLProxy["); a(def.name); a("VO] with "); a(def.name); a("VOProxy {\n");
			a("    def toXML(vo:"); a(def.name); a("VO): NodeSeq = outer.toXML(vo);\n");
			a('    def setValueObject(vo: '); a(def.name); a('VO, xml: NodeSeq) : Option['); a(def.name); a('VO] = outer.setValueObject(vo, xml);\n');
			a("  }\n");
		}
		
		ac('}'.code);
	}
}

class XMLProxyGenerator
{
	var code	: StringBuf;
	var def		: ClassDef;
	var map		: XMLMapping;
	var root	: XMLMapNode;
	var addSuperClassMapping : Bool;
	
	var xmlConverters : Hash<String>;
	var dependencies: Hash<Bool>;
	
	public function new(code:StringBuf, def:ClassDef, map:XMLMapping)
	{
		Assert.that(map != null);
		Assert.that(Std.is(map, XMLMapping), Std.string(map));
		
		this.code = code;
		this.def  = def;
		this.map  = map;
		this.root = map.getMergedMapping();
		
		if (root.children.length == 0) throw "no child?!";
		
		this.xmlConverters = new Hash();
		dependencies = new Hash();
		findDependencies(map.root);
		
		if (def.superClass != null && def.superClass.defaultXMLMap != null && !def.superClass.defaultXMLMap.root.isXMLTypeMap()) {
			addSuperClassMapping = true;
			dependencies.set(def.superClass.fullName, true);
		}
	}
	
	function addDependencyForValue(value) switch (value)
	{
		case XM_children(path, prop),
		 	 XM_child	(path, prop):
			
			var cl = Util.unpackPTypedef(Util.getPTypedef(prop.type));
		/*	if (Std.is(cl, NamedSetDef)) {
				cl = Util.unpackPTypedef(Util.getPTypedef(cast(cl, NamedSetDef).baseType));
			}
		*/	dependencies.set(cl.fullName, true);
		
		case XM_typeMap(map):			for (k in map.keys()) dependencies.set(map.get(k).fullName, true);
		
		default:
	}
	
	function findDependencies(node:XMLMapNode)
	{
		if (node.value != null)
			addDependencyForValue(node.value);
		
		if (node.attributes != null) for (a in node.attributes)
			addDependencyForValue(a);
		
		for (c in node.children)
			findDependencies(c);
	}
	
	public function implicits()
	{
		for (i in xmlConverters) a(i);
	}
	
	public function genDependencies()
	{
		MutableScala.addComponentDependencies(code, dependencies, "VOXMLComponent");
	}
	
	public function fromXML()
	{
		a('\n  def setValueObject(valueobject: '); a(def.name); a('VO, xml: NodeSeq) : '); a(def.name); a('VO =');
		
	 	if (gen_fromXMLValueToTypeMapping(map.root))
			return;
		
		a("\n  {");
		a("\n    val vo = if (valueobject != null) valueobject else new "); a(def.name); a("VO;\n");
		if (addSuperClassMapping)
		{
			a("\n    setValueObject(vo.asInstanceOf["); a(def.superClass.fullName); a("VO], xml);");
			// Don't use the merged map, since we can rely on superClass setValueObject calls.
			fromXMLNode(map.root, "vo.", 2);
		}
		else
		{
			fromXMLNode(root, "vo.", 2);
		}
		a("\n    vo");
		a("\n  }\n");
	}
	
	function fromXMLNode(node:XMLMapNode, varPrefix:String, indentLevel:Int)
	{
/*		for (c in node.children) if (isMultiChildXMLMap(c.value)) {
			//TODO: iterables
			ac('\n'.code);
			indent(indentLevel);
			add_fromXMLValue(c.value, varPrefix);
		}
*/		
		#if debug
		a('println("'); for (i in 0 ... indentLevel) ac(' '.code); a(def.fullName); a(': " + xml.headOption.map(_.label).getOrElse("-"))\n');
		#end
		
		// Multiple childnodes mapped props:
		for (child in node.children) if (isMultiChildXMLMap(child.value)) {
	 		indent(indentLevel); a("//  Multi, firstNode: "); a(child.nodeName); a('\n');
			indent(indentLevel);
			add_fromXMLValue("multi", child.value, varPrefix);
			a('\n');
		}
		
		// The rest...
		
		if (node.value != null && node.valuePath != null && !isMultiChildXMLMap(node.value)) {
	 		a('\n');
			indent(indentLevel); a("//  Node value: "); a(node.nodeName); a('\n');
			indent(indentLevel);
			add_fromXMLValue("xml.text", node.value, varPrefix);
		}
		
		if (node.children.length == 1)
		{
			var root = node.children[0];
			
			ac('\n'.code);
			indent(indentLevel); a("//  <"); a(root.nodeName); a('>\n');
			indent(indentLevel);
			if (isChildXMLMap(root.value)) {
				add_fromXMLValue("I#^%@HKJD", root.value, varPrefix);
			}
			else if (!isMultiChildXMLMap(root.value))
			{
				a('xml.headOption map { xml =>\n');
				fromXMLNode(root, varPrefix, indentLevel+1);
				gen_fromNodeAttr(root, varPrefix, indentLevel+1);
				ac('\n'.code);
				indent(indentLevel); a('}\n');
			}
		}
		else if (node.children.length > 1)
		{
			ac('\n'.code);
			indent(indentLevel);
			if (node.nodeName == "")
			 	a('for (xml <- xml) ');
			a('for (xml <- xml.child) if (xml.isInstanceOf[scala.xml.Elem]) {\n');
			
			#if debug
			a('println("'); for (i in 0 ... indentLevel + 1) ac(' '.code); a('" + xml.label)\n');
			#end
			indent(indentLevel+1);	a('xml.label match {');
			
			for (child in node.children) if (!isMultiChildXMLMap(child.value)) {
				ac('\n'.code);
				indent(indentLevel + 2); a('case "'); a(child.nodeName); a('" => ');
				#if debug
				a('println("'); for (i in 0 ... indentLevel + 2) ac(' '.code); a('" + xml.label)\n');
				#end
				fromXMLNode(child, varPrefix, indentLevel+3);
				gen_fromNodeAttr(child, varPrefix, indentLevel+3);
			}
			indent(indentLevel+2); a('case _ =>\n');
			indent(indentLevel+1); a('}\n');
			indent(indentLevel);   a('}');
		}
	}
	
	function gen_fromXMLValueToTypeMapping(node:XMLMapNode) : Bool
	{
		var code_added = false;
		
		// Handle value->type mappings first
		if (node.attributes != null) for (attr in node.attributes.keys()) switch (node.attributes.get(attr))
		{
			case XM_typeMap(map):
				if (code_added) throw "Error: multiple type-maps found";
				
				var matchAdded = false;
				
				for (k in map.keys())
				{
					if (!matchAdded) {
						a(' (xml \\ "@'); a(attr); a('").text match\n  {');
						matchAdded = true;
					}
					
					var clname = map.get(k).fullName;
					a('\n    case "'); a(k); a('" => outer.setValueObject(valueobject match { case v: '); a(clname); a("VO => v; case _ => new "); a(clname); a("VO }, xml);");
					
					code_added = true;
				}
				if (matchAdded) a("\n    case _ => valueobject\n  }\n");
			
			default:
		}
		
		for (child in node.children)
			if (code_added) throw "Error: multiple type-maps found";
			else code_added = gen_fromXMLValueToTypeMapping(child);
		
		return code_added;
	}
	
	function gen_toXMLValueToTypeMapping(node:XMLMapNode) : Bool
	{
		var code_added = false;
		
		// Handle value->type mappings first
		if (node.attributes != null) for (attr in node.attributes.keys()) switch (node.attributes.get(attr))
		{
			case XM_typeMap(map):
				if (code_added) throw "Error: multiple type-maps found";
				
				var added = new Hash<Bool>();
				var clname = null;
				
				a("vo match {");
				for (val in map) if (!added.exists(clname = val.fullName)) {
					a("\n    case vo:"); a(clname); a('VO => toXML(vo)');
					added.set(clname, true);
				}
				a('\n    case _ => null\n  }\n');
				
				code_added = true;
				
			default:
		}
		
		for (child in node.children)
			if (code_added) throw "Error: multiple type-maps found";
			else code_added = gen_toXMLValueToTypeMapping(child);
		
		return code_added;
	}
	
	function gen_fromNodeAttr(node:XMLMapNode, varPrefix:String, indentLevel:Int)
	{
		if (node.attributes != null)
		{
			ac('\n'.code);
			indent(indentLevel); a("for (xml <- xml.attributes) xml.key match\n");
			indent(indentLevel); ac("{".code);
			for (name in node.attributes.keys()) if (matchAttribute(node.attributes.get(name)))
			{
				ac('\n'.code);
				indent(indentLevel+1); a('case "'); a(name); a('" => ');
				add_fromXMLValue("xml.value.text", node.attributes.get(name), varPrefix);
			}
			ac('\n'.code);
			indent(indentLevel+1); a('case _ =>\n');
			indent(indentLevel);   a('}\n');
		}
	}
	
	public function toXML()
	{
		a("\n  def toXML(vo:"); a(def.name); a("VO): NodeSeq = ");
		
		if (gen_toXMLValueToTypeMapping(map.root))
			return;
		
		if (root.children.length == 1)
			gen_toNode(root.children[0]);
		else {
			a("\n  <xml>");
			for (child in root.children) gen_toNode(child, 2);
			a("\n  </xml>.child");
		}
		
		a('\n\n');
	}
	
	function gen_toNode(node:XMLMapNode, indentLevel:Int=1)
	{
		ac('\n'.code);
		indent(indentLevel);
		
		if (hasValue(node) && (isChildXMLMap(node.value) ||isMultiChildXMLMap(node.value)))
		{
			a('{ ');
			addToXMLWithCheckFieldIsSet(node.value, "vo.");
			a(' }');
			return;
		}
		
		ac('<'.code); a(node.nodeName);
	
		var atCount = 0;
	
		if (node.attributes != null) for (name in node.attributes.keys())
		{
			var attr = node.attributes.get(name);
			ac('\n'.code); indent(indentLevel + 1);
			
			// Handle simple strings first
			switch(attr) {
				case XM_empty:
				case XM_String(v):
					ass(name); ac('='.code); ac('"'.code); a(v); ac('"'.code);
			
				default:
					ass(name); a('={');
					addToXMLWithCheckFieldIsSet(attr, "vo.");
					ac('}'.code);
			}
		}
	
		if (!hasValue(node) && node.children.length == 0) {
			a("/>");
			return; // done
		}
	
		
		// Value or children
		a('>');
		
		if (hasValue(node))
		{
			Assert.that(node.children.length == 0);
			
			var brackets = false;
			
			switch(node.value) {
				case XM_empty:
				case XM_String(v): a(v);
				default:
					brackets = true;
			}
			
			if (brackets)
			{
				a('{ ');
				addToXMLWithCheckFieldIsSet(node.value, "vo.");
				a(' }');
			}
		}
		
		if (node.children.length > 0)
		{
		 	for (child in node.children) if (isMultiChildXMLMap(child.value)) {
				ac('\n'.code);
				indent(indentLevel+1); a("{ "); addToXMLWithCheckFieldIsSet(child.value, "vo."); a(" }");
			} else {
				gen_toNode(child, indentLevel + 1);
			}
			
			ac('\n'.code); indent(indentLevel);
		}
		a('</'); a(node.nodeName); a('>');
	}
	
	inline function addPathEscaped(path:String)
	{
		var pieces = path.split('.');
		var i = 0;
		for (s in pieces) {
			a(Scala.quote(s));
			if (++i != pieces.length) ac('.'.code);
		}
	}
	
	function add_ifStringSet(varName:String) {
		a("val s = "); a(varName); a("; if (s.length != 0) ");
	}
	
	function add_setVarFromString(varName:String, varPrefix:String, setterPath:String, type:PType, converterPrefix:String, format:String)
	{
		add_ifStringSet(varName);
		add_setVar(varPrefix, setterPath, type);
		
//		if (format != null) {
			a(converterPrefix);
			add_conversionFromStringFunction(type);
			ac("(".code); a("s"); if (format != null) { a(', "'); a(format); ac('"'.code); } ac(")".code);
//		}
//		else {
//			a("s");
//		}
//		if (Util.isEnum(type)) {
//			a(".getOrElse(null)");
//		}
	}
	
	function add_setVar(varPrefix:String, setterPath:String, type:PType)
	{
		a(varPrefix);
		switch (type) {
			case TenumConverter(_):
				addPathEscaped(setterPath.substr(0, setterPath.lastIndexOf('.'))); // strip enum converter property
			default:
				addPathEscaped(setterPath);
		}
		a(" = ");
	}
	
	function add_conversionFromStringFunction(type) switch (type)
	{
		case Tstring:
		default:
			a(Scala.convertFromAnyRefTo(type));
	}
	
	function matchAttribute(v:XMLMapValue) return switch (v) {
		case XM_empty, XM_String(_), XM_typeMap(_):
		 	false;
		default: true;
	}
	
	function add_fromXMLValue(varName:String, v:XMLMapValue, varPrefix:String, converterPrefix:String = "")
	{
		// Handle expressions
		switch(v)
		{
			case XM_empty, XM_String(_), XM_typeMap(_):
				// Not a value type
				
			case XM_binding		(path, prop), XM_toInt(path, prop):
				add_setVarFromString(varName, varPrefix, path, prop.type, converterPrefix, null);
			
			case XM_not			(v):
				add_fromXMLValue(varName, v, varPrefix, converterPrefix + "!");
			
			case XM_format		(path, prop, format):
				add_setVarFromString(varName, varPrefix, path, prop.type, converterPrefix, format);
			
			case XM_join		(path, prop, seperator):
				add_ifStringSet(varName);
				add_setVar(varPrefix, path, prop.type);
				a(converterPrefix);
				add_conversionFromStringFunction(prop.type);
				a('('); a(varName); a('.split("'); a(seperator); a('"))');
				
			case XM_concat		(values):
				throw "not implemented";

			case XM_children	(path, prop),
			 	 XM_child		(path, prop):
				
				
				var clname = Util.unpackPTypedef(Util.getPTypedef(prop.type)).fullName;
				
				if (Util.isPTypeIterable(prop.type)) {
					a("val tmp_"); a(path); a(" = ");
					a("xml.child.iterator.filter(_.isInstanceOf[scala.xml.Elem]) map { node => ");
					a("outer.setValueObject(new "); a(clname); a("VO, node) ");
					a("} filterNot(_.empty_?) toArray;");
					a("  if (tmp_"); a(path); a(".length > 0) ");
					add_setVar(varPrefix, path, prop.type);
					a("tmp_"); a(path);
				}
				else {
					a("outer.setValueObject("); a(varPrefix); a(path); a(", xml)");
				}
		}
	}
	
	function isMultiChildXMLMap(value:XMLMapValue)
	{
		return value != null && switch (value)
		{
			case XM_children(_,_): true;
			default: false;
		}
	}
	
	function isChildXMLMap(value:XMLMapValue)
	{
		return value != null && switch (value)
		{
			case XM_child(_,_): true;
			default: false;
		}
	}
	
	function addCheckFieldIsSet(v:XMLMapValue, pathPrefix) switch (v)
	{
		// Handle fieldIsSet_?
		case XM_binding(path,prop),
		 	 XM_toInt(path,prop),
		 	 XM_format(path,prop,_),
			 XM_child(path,prop),
		 	 XM_children(path,prop),
		 	 XM_join(path,prop,_):
			
			if (Util.isEnum(prop.type))
				return false;
			
			var objPathEnd = path.lastIndexOf('.');
			
			var fieldIndex = prop.bitIndex();
			
			a("if ("); a(pathPrefix);
			if (objPathEnd != -1) {
				a(Scala.quote(path.substr(0, objPathEnd))); ac('.'.code);
			}
			a("fieldIsSet_?("); a(fieldIndex+" /*"); a(prop.parent.fullName); a(" */)) ");
			
			return true;
		
		case XM_not(v):
			return addCheckFieldIsSet(v, pathPrefix);
		
		default:
			return false;
	}
	
	function addToXMLWithCheckFieldIsSet(v:XMLMapValue, pathPrefix)
	{
		if (addCheckFieldIsSet(v, pathPrefix)) {
			addToXMLValue(v, pathPrefix);
			a(' else NodeSeq.Empty'); // Check if else null will not give problems with the PHP cms
		}
		else
			addToXMLValue(v, pathPrefix);
	}
	
	function addToXMLValue(v:XMLMapValue, pathPrefix) switch (v)
	{
		case XM_typeMap(_), XM_String(_): throw "Should have been handled already...";
		
		case XM_binding		(path,prop):
			addConvertedToString(pathPrefix + path, prop.type);
		
		case XM_toInt		(p,v):
			a("new scala.xml.Unparsed(("); addIntString(pathPrefix + p, v.type); a(").toString)");
		
		case XM_not			(v): 
			addToXMLValue(v, "!"+pathPrefix);
		
		case XM_format		(path,prop,format):
			a("xml.Text(ConvertTo.string(");
			addPathEscaped(pathPrefix + path);
			a(",\"");
			a(format);
			a("\"))");
		
		case XM_join		(path,val,seperator):
			var a = a;
			switch (val.type) {
				default:
					throw "Only array joins are supported. v="+v+", pathPrefix="+pathPrefix;
				
				case Tarray(elemT, min, max):
					switch(elemT) {
						case Tstring:
						default:
							throw "Only Array<String> joins are supported.";
					}
					a(pathPrefix); addPathEscaped(path); a('.mkString("'); a(seperator); a('")');
			}
		
		case XM_concat		(values):
			for (i in 0 ... values.length) {
				addToXMLValue(values[i], pathPrefix);
				if (i <= values.length - 2) a(" + ");
			}
		
			trace(code.toString());
			//throw "not implemented";
		
		case XM_empty:								throw "Empty attribute? ";
		
		case XM_children	(path,from), XM_child(path,from):
			add_toXMLChildren(pathPrefix + path, from.type);
	}
	
	function add_toXMLChildren(path, type) switch(type)
	{
		case Tdef(t):
			var clname = Util.unpackPTypedef(t).fullName;
			a("toXML("); addPathEscaped(path); a(")");
		
		default:
			switch(type)
			{
				case Tarray(t,_,_):
					addPathEscaped(path);
				 	a(".iterator.map({ i => "); add_toXMLChildren("i", t); a(" })"); // _.toXML())");
				
				default: throw "impossible";
			}
	}
	
	function addConvertedToString(path, type) switch (type)
	{
/*		case Tdef(tdef): switch (tdef) {
			case Tclass(cl):	throw "class to string?";
			case Tenum(cl):		a("(if ("); addPathEscaped(path); a(" != null) xml.Text(ConvertTo.string("); addPathEscaped(path); a(")) else NodeSeq.Empty)");
		}
*/		
		case TenumConverter(_): a("(if (!"); addPathEscaped(path); a(".isEmpty) xml.Text("); addPathEscaped(path); a(") else NodeSeq.Empty)");
		
		case Tstring:
			a("xml.Text(");
			addPathEscaped(path);
			a(")");
			
		case Tbool(_), Tinteger(_,_,_):
			a("new scala.xml.Unparsed(("); addPathEscaped(path); a(").toString)");
			
		default:
			a("xml.Text(ConvertTo.string("); addPathEscaped(path); a("))");
	}
	
	inline function indent(times:Int) for (i in 0 ... times) a("  ")
	
	function addIntString(path, type) switch(type)
	{
		case Tbool(val):				a("if ("); addPathEscaped(path); a(") 1 else 0");
		case Tinteger(min,max,stride):	addPathEscaped(path);
		case Tdecimal(min,max,stride):	addPathEscaped(path); a(".toInt");
		case Tstring:					addPathEscaped(path); throw "Int String? "+path+" : "+type;
		case Tcolor:					addPathEscaped(path); a(".toInt");
		case Tdate:						addPathEscaped(path); a(".getMillis()");
		case Tdatetime:					addPathEscaped(path); a(".getMillis()");
		
		default: throw "not implemented for type: "+type;
	}
	
	inline function hasValue(node) return node.value != null && node.value != XM_empty
	
	// Adds space then String :-)
	inline function ass(s:String) {
		ac(" ".code);
		a(s);
	}
	
	inline function a(str) code.add(str)
	inline function ac(ch) code.addChar(ch)
}

class ScalaMessagePacking extends MessagePacking
{
	override private function expr_incrementMixinCount()	return "mixin += 1"
	override private function a_return() a("return")
	override private function a_not0(v:String) {
		a(v); a(" != 0");
	}
	
	override private function a_is0(v:String) {
		a("("); a(v); a(") == 0");
	}
	
	override private function a_packVOHeaderCallStart() {
		a("\n\t\to.packValueObjectHeader("); a(Std.string(def.index)); a(", ");
	}
	
	override private function a_msgpackVOCallStart(t : TypeDefinition) {
		a("\n\t\t\t"); addFullName(t); a(".msgpack_packVO(o, obj, ");
	}
	
	override private function a_assert(v:String) {
		a("require("); a(v); a(");");
	}

	override private function a_maskByte(mask:Int, byte:String) {
		return if (mask > 0xFF){ a(byte); a(" & 0xFF"); } else { a(byte); a(" & 0x"); a(StringTools.hex(mask, 2)); };
	}
	override private function a_writeByte(byte:String, mask:Int = 0xFFFFFF) {
		a("o.writeByte("); a(byte); a(");");
	}
	override private function endPackerFunction() {
		a("\n\t}\n");
	}
	override private function addFieldIndexOffsetCase(t : TypeDefinition, offset : Int) {
		a("\n    case "); a(Std.string(t.index)); a(" => "); a(offset + ";"); a(" // "); a(t.fullName);
	}
	
	override private function addPropertyPackerCall(path:String, pType:PType, bindable:Bool)
	{
		if (path.indexOf("obj.") == 0) {
			path = "obj." + Scala.quote(path.substr(4));
		}
		
		switch (pType)
		{
			case Tdef(tdef): switch(tdef) {
				case Tclass(_):	a('o.pack('); a(path); ac(")".code);
				case Tenum(_):	a('o.pack('); a(path); a(".value)");
			} 
			
			case Tarray(_,_,_), Tbool(_), Tinteger(_,_,_), Tdecimal(_,_,_), Tstring, Tdate, Tdatetime, Tinterval, Turi, Turl, TuniqueID, Temail, Tcolor, TfileRef:
				a('o.pack('); a(path); ac(")".code);
			
			
			case TenumConverter(_), TclassRef(_):
				throw "Not implemented";
		}
	}
	
	override private function definePackerFunction()
	{
		a("\n\tfinal def msgpack_packVO(o : VOPacker, obj : "); a(def.name); a(", flagsToPack : Int)\n\t{"); //"); a(Module.pkgRoots.first().name); a("]
		a("\n		require(o != null && obj != null);");
		a("\n		");
		a("\n		var propertyBits = flagsToPack;");
	}
	
	override private function genDeSerialization(lastProp)
	{
		fieldIndexOffset = new IntHash();
		
		a("\n  def defaultVOCompanionMap = ");
		var pkgroot = def.module.getPackageRoot();
		if (pkgroot != Module.root) {
			a(pkgroot.fullName); a(".VO.typeMap");
		}
		else a("null");
		
		a("\n  val TypeID = "); a(Std.string(def.index));
		a("\n  final def fieldIndexOffset(typeID: Int) = typeID match {");
		genFieldOffsetCases(def);
		a("\n  }\n");
	}
	
	override private function a_unpackProperty(p:Property)
	{
		a(p.name); a(" = "); a("input.unpack();");
	}
}
