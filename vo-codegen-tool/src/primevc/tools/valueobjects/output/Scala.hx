package primevc.tools.valueobjects.output;
 import primevc.tools.valueobjects.VODefinition;
  using primevc.utils.TypeUtil;

class Scala implements CodeGenerator
{
	private static var writelist = new List<Scala>();
	
	public static function generate() {
		Module.root.generateWith(new Scala(Module.root));
		
		var filename = "ValueObjects.scala";
		
		trace("WRITING: "+filename);
		var file = neko.io.File.write(filename, false);
		file.writeString(
"// GENERATED BY VOCompiler - MODIFICATIONS WILL BE LOST

import scala.collection.JavaConversions
import scala.xml.NodeSeq
import primevc.types._
import primevc.utils._
import primevc.utils.msgpack._
import primevc.core.traits._
import primevc.mvc.mongodb._
import com.mongodb.casbah.Imports._

");
		
		for (m in writelist) m.write(file);
		
		file.close();
	}
	
	private function new(m:Module) {
		this.mod = m;
		this.code = new StringBuf();
		writelist.add(this);
	}
	
	function write(file:neko.io.FileOutput)
	{
		if (!shouldWrite) return;
		
		file.writeString("\n\npackage ");
		file.writeString(this.mod.fullName);
		
		file.writeString("\n{\n\n");
		file.writeString(code.toString());
		file.writeString("\n\n} // end ");
		file.writeString(this.mod.fullName);
	}
	
	var mod			: Module;
	var code		: StringBuf;
	var dir			: String;
	var shouldWrite : Bool;
	
	var currentFieldBitNum : Int;
	
	public function newModule	(m:Module)		: CodeGenerator
	{
		trace("\n- Scala module: "+m.fullName);
		return new Scala(m);
	}
	
	inline function a(str) code.add(str)
	inline function ac(ch) code.addChar(ch)
	
	
	
	public function genClass	(def:ClassDef)	: Void
	{
		shouldWrite = true;
		
		trace("  - Scala class:  "+def.name);
		
	// --- VO class definition
		var thisPropsStartIndex = null, typeParamCount = 0, idType:String = null, idFromSuperclassOrTrait = false, idProperty:Property = null, 
			nonEmptyChecks = 0, emptyChecks = new List<{expr:String, id:Int}>();
		
		var hasSubtypes = false;
		var subtypes : List<ClassDef> = new List();
		for (imp in def.implementedBy) if (cast(imp, ClassDef).extendsType(def)) {
			subtypes.add(cast imp);
			hasSubtypes = true;
		}
		
		var superClassHasBitflags = false;
		var fullName = def.fullName;
		// Check if this is a NamedSetDef
		var ns:NamedSetDef = Std.is(def, NamedSetDef)? cast def : null;
		
		for (i in 0 ... def.propertiesSorted.length)
		{
			var p = def.propertiesSorted[i];
			if (needsMongoHelperClass(p.type)) typeParamCount++;
			
			if (thisPropsStartIndex == null && !Util.isDefinedInSuperClassOf(def, p))
				thisPropsStartIndex = i;
			
			// Check if empty_? needs to be overridden
			if (!Util.isDefinedInSuperClassOf(def, p)) switch (p.type)
			{
				case Tdef(cl): switch (cl) {
					case Tclass(cl):	emptyChecks.add({expr: "($"+ p.name +" == null || $"+ p.name + ".empty_?)", id: i});
					case Tenum(e):		emptyChecks.add({expr: "($"+ p.name +" == null || $"+ p.name + ".toString.isEmpty)", id: i});
				}
				
				case Tarray(_,_,_):
					emptyChecks.add({expr: "($"+ p.name +" == null || $"+ p.name +".length == 0)", id: i});
				
				case Tstring, TfileRef, Tdate, Tdatetime, Tinterval, Tcolor, Temail, Turi, TuniqueID, Tinteger(_,_,_), Tdecimal(_,_,_), Tbool(_):
					++nonEmptyChecks;
				
				case TenumConverter(_):		throw p;
			}
			else switch (p.type) {
				case TfileRef, Tdate, Tdatetime, Tinterval, Tcolor, Temail, Turi, TuniqueID, Tinteger(_,_,_), Tdecimal(_,_,_), Tbool(_):
					superClassHasBitflags = true;
				default:
			}
			
			if (p.hasOption(unique))
			{
				if (idProperty != null) throw "VO's may have only 1 ID property...\n  idProperty = "+idProperty+"\n"+def;
				idProperty = p;
				idType = getType(p.type).name;
				
				if (p.definedIn != def)
					idFromSuperclassOrTrait = true;
			}
		}
		
		a("\n\n//---\n\nsealed trait "); a(def.name); a(" extends ");
		// extra stuff
		if (ns != null)
		{
			if (ns.keys.length > 0) {
			//	a("scala.collection.mutable.HashSet[");
			//	a(getType(ns.baseType).name);
				a("primevc.core.traits.NamedSet["); a(getType(ns.baseType).name); // a("] with ");
			//	a("scala.collection.mutable.SetLike["); a(getType(ns.baseType).name); a(", "); a(def.name); a("VO");
			}
			else {
				a("ValueObject"); if (idType != null) a("WithID");
				a(" with scala.collection.Traversable[");
				a(getType(ns.baseType).name);
			}
			a("]");
		}
		else if (def.superClass != null) {
			a(def.superClass.fullName);
		}
		else {
			a("ValueObject"); if (idType != null) a("WithID");
		}
		
		
		//TODO: Generate traits for supertypes ?
		for (t in def.supertypes) if (Std.is(t, MagicClassDef) || def.superClass != t) {
			 a("\n with "); a(t.fullName);
		}
		
		a("\n{");
		
		// properties
		var requiredProps = new List<Int>();
		currentFieldBitNum = thisPropsStartIndex;
		
		for (p in def.propertiesDefined)
			writeVarGetter(p);
		a("\n}\n\n");
		
		if (def.isMixin) {
			genCompanion(def, idProperty, ns, thisPropsStartIndex, hasSubtypes, subtypes);
			return;
		}
		
		// -- end trait
		//
		// VO Class
		
		a("\n\nsealed class "); a(def.name); a("VO");
		
		if (idType != null) {
			a(def.superClass != null? " (_id:" : " (val _id:");
			a(idType); a(" = "); a(nilValue(idProperty.type)); a(")");
		}
		a(" extends ");
		
		if (def.superClass != null) {
			a(def.superClass.fullName); a("VO");
			if (idType != null) a("(_id)");
			a(" with ");
		}
		
		a(def.name); a("\n{");
		
		for (i in thisPropsStartIndex ... def.propertiesSorted.length) {
			var p = def.propertiesSorted[i];
			var r = p.hasOption(required);
			if (r) requiredProps.add(i);
			writeSetter(i, p);
		}
		
		
		
		// IDType
		if(idType != null && !idFromSuperclassOrTrait) {
			a("\n  type IDType = "); a(idType); ac("\n".code);
		}
		
		// Companion getter
		a("\n  override def Companion : VOCompanion[_] with VOMessagePacker[_] = "); a(def.name); a("VO");
		
		// partial_?
		if (def.propertiesSorted.length != 0) {
			a("\n  override def partial_? = numFieldsSet_? != "); a(Std.string(def.propertiesSorted.length));
		}
		
		// Non-bitflag empty checks overrides
		if (emptyChecks.length > 0)
		{
			var andAnd;
			
			// empty_?
			a("\n  override def empty_? = ");
			if (def.superClass != null || nonEmptyChecks != 0) {
				a("super.empty_?");
				andAnd = true;
			}
			else andAnd = false;
			
			for (check in emptyChecks) {
				if (andAnd) a(" && ");
				andAnd = true;
				a(check.expr);
			}
			
			// updateFieldsSet_!
			a("\n  override def updateFieldsSet_! = {");
			if (def.superClass != null || nonEmptyChecks != 0) {
				a("\n    super.updateFieldsSet_!;");
			}
			for (check in emptyChecks) {
				a("\n    if (!"); a(check.expr); a(") $fieldsSet |= 0x"); a(StringTools.hex(1 << check.id)); a(";");
			}
			a("\n  }");
			
			// fieldIsSet_?
			a("\n  override def fieldIsSet_?(index:Int) = index match {");
			for (check in emptyChecks) {
				a("\n    case " + check.id); a(" => !"); a(check.expr);
			}
		 	a("\n    case _ => super.fieldIsSet_?(index)");
			a("\n  }");
		}
		
		
		// validation
		if (requiredProps.length != 0)
		{
			a("\n  override def validationErrors_? = {\n    var errors : List[(Symbol,String)] = Nil");
			for (i in requiredProps)
			{
				a("\n    if (!fieldIsSet_?("); a(Std.string(i)); a(")) errors ::= ('"); a(def.propertiesSorted[i].name); a(', "error.required")');
			}
			a("\n    errors\n  }\n");
		}
		
		// extra stuff
		if (Std.is(def, NamedSetDef))
			genNamedSetDefMethods(cast def);
		
		a("\n}\n\n");
		
	// --- End VO class
		genCompanion(def, idProperty, ns, thisPropsStartIndex, hasSubtypes, subtypes);
	}
	
	private function genCompanion(def:ClassDef, idProperty:Property, ns, thisPropsStartIndex, hasSubtypes, subtypes:List<ClassDef>)
	{
		// VO MessagePacker object
		a("object "); a(def.name);
		
		if (def.isMixin)
		{
			a(" extends VOMessagePacker["); a(def.name); a("]\n{");
			
			// MessagePack serialization
			new ScalaMessagePacking(code, def).genSerialization();
			
			a("}\n\n");
			return;
		}
		
		// ---
		// Regular VO class Companion
		// ---
		a("VO extends VOCompanion["); a(def.name); a("VO"); a("] with VOMessagePacker["); a(def.name); a("]");
		
		if (idProperty != null) {
			a(" with "); a(def.name); a("IDAccessor");
		}
		a("\n{");
		
		// MessagePack serialization
		new ScalaMessagePacking(code, def).genSerialization();
		
		a("\n  override def empty: "); a(def.name); a("VO = new "); a(def.name); a("VO;\n");
		
		// afasjfakjfhaf
		if (ns != null && ns.keys.length > 0)
		{
//			a("\n  override def getValue(vo:"); a(def.name); a("VO, key:String): AnyRef = vo.get(key)");
			a("\n  override def putValue(vo:"); a(def.name); a("VO, key:String, value:AnyRef): "); a(def.name); a("VO = { vo.addEntry(ConvertTo.vo["); a(getType(ns.baseType).name); a("](value)); vo; }");
//			a("\n  override def fieldsSetNames(vo:"); a(def.name); a("VO) = vo.keySet");
		}
		
		// field()
		if (thisPropsStartIndex != null)
		{
			for (i in 0 ... def.propertiesSorted.length)
			{
				var p = def.propertiesSorted[i];
				a("\n  val "); a(quote(p.name));
				if (p.parent == def)
				{
				 	a(" = Field('"); a(p.name); a(", ");
					addFieldTypeConstructor(p.type, p.hasOption(mongo_reference));
					if (p.hasOption(required)) {
						a(", required = true");
					}
					a(")");
				}	
				else {
					a(" = "); a(p.parent.fullName); a("VO."); a(quote(p.name));
				}
			}
			
			a("\n\n  override val numFields = "+def.propertiesSorted.length);
			// field(Int)
			a("\n\n  override def field(index: Int) = index match {");
			for (i in 0 ... def.propertiesSorted.length)
			{
				var p = def.propertiesSorted[i];
				a("\n    case "+ i); a(" => this."); a(quote(p.name));
			}
			a("\n    case _ => super.field(index)");
			a("\n  }");
			
			// field(String)
			a("\n\n  override def field(key: String) = key match {");
			for (i in 0 ... def.propertiesSorted.length)
			{
				var p = def.propertiesSorted[i];
				a('\n    case "'); if (p.hasOption(unique)) a('_id" | "');  a(p.name); a('" => '+i);
			}
			a("\n    case _ => super.field(key)");
			a("\n  }");
		}
		
		if (def.propertiesSorted.length == 0)
		{
			a("\n  def getValue(vo:"); a(def.name); a("VO, index:Int) : AnyRef = null");
			a("\n  def putValue(vo:"); a(def.name); a("VO, index:Int, value:AnyRef) : "); a(def.name); a("VO = vo\n");
		}
		else
		{
			// getValue()
			a("\n\n  def getValue(vo:"); a(def.name); a("VO, index:Int) : AnyRef = ");
			if (def.superClass != null && thisPropsStartIndex == null) {
				a(def.superClass.fullName); a("VO.getValue(vo, index);\n");
			}
			else
			{
				a("(index match {\n");
				for (i in 0 ... def.propertiesSorted.length) {
					var p = def.propertiesSorted[i];
					a('    case '+i); a(' => vo.'); a(propertyName(p)); a('\n');
				}
				a("    case _ => null\n  }).asInstanceOf[AnyRef]\n\n");
			}

			// putValue(vo, index:Int, value)
			a("  def putValue(vo:"); a(def.name); a("VO, index:Int, value:AnyRef) : "); a(def.name); a("VO = ");
			if (def.superClass != null && thisPropsStartIndex == null) {
				a(def.superClass.fullName); a("VO.putValue(vo, index, value).asInstanceOf["); a(def.name); a("VO];\n");
			}
			else
			{
				a("{ index match {\n");
				for (i in 0 ... def.propertiesSorted.length) {
					var p = def.propertiesSorted[i];
					a('    case '+i); a(' => vo.'); a(p.name); a("_("); a("value );\n");
				}
				a("  }; vo; }\n");
			}
		}
		
		a("}\n\n");
		
		// VOAccessor
		a("trait "); a(def.name); a("VOAccessor //extends VOAccessor["); a(def.name); a("VO]\n{\n");
			// _fields
			a("  def field    (vo: "); a(def.name); a("VO, key:String) : Int    = "); a(def.name); a("VO.field(key);\n");
			a("  def field    (vo: "); a(def.name); a("VO, index: Int) : Field  = "); a(def.name); a("VO.field(index);\n");
			a("  def fieldsFor(vo: "); a(def.name); a("VO) : IndexedSeq[Field]  = "); a(def.name); a("VO.fields;\n");
			a("  def isSet    (vo: "); a(def.name); a("VO, key:String): Boolean = vo.fieldIsSet_?(field(vo, key));\n");
			
			a("  def getValue (vo: "); a(def.name); a("VO, key:String) : AnyRef = "); a(def.name); a("VO.getValue(vo, key)\n");
			a("  def putValue (vo: "); a(def.name); a("VO, key:String, value:AnyRef) : "); a(def.name); a("VO = "); a(def.name); a("VO.putValue(vo, key, value)\n");
		a("}\n");	
		
		// IDAccessor & VOProxy
		if (idProperty != null)
		{
			var idType = getType(idProperty.type).name;
			
			a("trait "); a(def.name); a("IDAccessor extends IDAccessor["); a(def.name); a("VO] {\n");
				a("  val idField = " ); a(idProperty.definedIn.fullName); a("VO."); a(idProperty.name); a('\n');
				a("  def idValue(vo:"); a(def.name); a("VO): "); a(idType); a(" = if(vo == null) "); a(nilValue(idProperty.type)); a(" else vo."); a(idProperty.name); ac("\n".code);
				a("  def idValue(vo:"); a(def.name); a("VO, idValueToSet:"); a(idType); a(") = { vo."); a(idProperty.name); a(" = idValueToSet; }\n");
			a("}\n");
			// VOFieldInfo
			a("trait "); a(def.name); a("FieldInfo extends VOFieldInfo {\n");
				a('  override val numFields = '); a(def.name); a('VO.numFields;\n');
				a("  override def field(index: Int): Field = "); a(def.name); a('VO.field(index);\n');
				a("  override def field(key: String): Int = " ); a(def.name); a('VO.field(key);\n');
			a("}\n");
			a("trait "); a(def.name); a("VOProxy extends "); a(def.name); a("IDAccessor with "); /*a(def.name); a("VOAccessor with ");*/ a(def.name); a("FieldInfo\n");
		}
		
		// Mongo service Component
		a("\ntrait "); a(def.name); a("VOMongoComponent extends MongoComponent with "); a(def.name); a("VOAccessor\n{"); // ["); a(def.name); a("VO] with "); a(def.name); a("VOAccessor\n { ");
			// dependencies
			addMongoComponentDependencies(def, subtypes);
			
/*			if (implicitRefsDefined)
			{
				for (clname in implicitRefProxy.keys()) {
					a("\n  implicit val "); addClassProxy(clname, "");
				}
				ac('\n'.code);
			}
//					addLowerCaseFirst(clname.substr(this.mod.fullName.length + 1).split('.').join('_'));
*/			
			// asDBObject()
			a("\n  def asDBObject(vo: "); a(def.name); a('VO): DBObjectVO[_] = ');// a(def.name); a('VO] = ');
			if (hasSubtypes)
			{	
				a("vo match { ");
				for (t in subtypes) {
					a("\n    case v : "); a(t.fullName); a("VO => asDBObject(v); ");
				}
				a("\n    case _ => ");
			}
			
			a('new DBObjectVO(vo) {\n');
			a('      override def containsField(name: String) = outer.isSet(vo, name);\n');
			a('      override def keySet: java.util.Set[String] = keySet(fieldsFor(vo), field(vo, _));\n');
			a('      override def put(key:String, value:AnyRef) : AnyRef = outer.putValue(vo, key, value);\n');
			a('      override def get(key:String) : AnyRef = key match {\n');
			
			if (hasSubtypes || def.superClass != null)
			{
				a('        case "cast" => '); a(def.index + ".asInstanceOf[AnyRef];\n");
			}
			
			for (p in def.property)
			{
				if (p.hasOption(mongo_reference)) {
					a('        case "'); a(p.name); a('" => vo.'); a(quote(p.name)); a(".ref;\n");
				}
				else switch (p.type)
				{
					case Tdef(t):
						a('        case "'); a(p.name); a('" => ');
						if (Util.isEnum(p.type)) {
							a('vo.'); a(quote(p.name)); a('.toString;\n');
						} else {
							a('asDBObject(vo.'); a(quote(p.name)); a(');\n');
						}
				
					case Tarray(t, _, _):
						a("  "); addVOGetterCase(p);
						if (!Util.isPTypeBuiltin(t)) {
							a('.filter(v => v != null && !v.empty_?).map(outer.asDBObject(_)');
							if (p.hasOption(mongo_typeCast)) a(".withTypeCast()");
							a(');\n');
						} else {
							a('.filter(_ != null).map(ConvertTo.string(_));\n');
						}
				
					case Tcolor:					a("  "); addVOGetterCase(p); a('.toInt.asInstanceOf[AnyRef];\n');
					case Turi, Temail, TfileRef:	a("  "); addVOGetterCase(p); a('.toString;\n');
					case Tdate,Tdatetime:			a("  "); addVOGetterCase(p); a('.toDate;\n');
					case Tinterval:					a("  "); addPropnameCase(p); a("new IntervalDBObject(vo."); a(quote(p.name)); a(");\n");
					
					default:
				}
			}
			a('        case _ => outer.getValue(vo, key)\n');
			a('      }\n');
			if (hasSubtypes) a("    }\n");
			a('  }\n');
		
			// setValueObject()
			a("\n  def setValueObject(vo: "); a(def.name); a("VO, dbo: MongoDBObject): "); a(def.name); a("VO = {");
			
			a('\n    if (vo == null) ');
			
			if (hasSubtypes) // at least one subclass
			{
				a('dbo.getAs[Int]("cast") match { case Some(id) if (id != ' + def.index); a(') => id match { ');
				for (t in subtypes) {
					a("case "+t.index); a(" => setValueObject(new "); a(t.fullName); a("VO, dbo); ");
				}
				a('}; case _ => setValueObject(new ');
				a(def.name); a('VO, dbo) }');
			}
			else {
				a("setValueObject(new "); a(def.name); a('VO, dbo)');
			}
			a("\n    else {\n");
			
			for (i in thisPropsStartIndex ... def.propertiesSorted.length) {
				var p = def.propertiesSorted[i];
				a("      "); writeMongoGetter(p, "vo." + propertyName(p));
			}
			if (def.superClass != null) {
				a("      setValueObject(vo.asInstanceOf["); a(def.superClass.fullName); a("VO], dbo);\n");
			}
			a("      vo\n    }\n");
			a("  }\n");
			
//			a("\n  def asValueObject(dbo: MongoDBObject): "); a(def.name); a("VO = setValueObject(new "); a(def.name); a("VO, dbo);\n ");
			
		if (def.settings.mongo_proxied != none)
		{
			// Abstract mongo proxy
			var moduleFullName = def.module.fullName;
			var collectionName = (def.module.name == "vo"? moduleFullName.substr(0, moduleFullName.length - 3) : moduleFullName).split('.').join('_');
		
			a("\n  class "); a(def.name); a("VOMongoProxy (database:String = null, collection:String = null, connection:MongoConnection = null)\n");
			a("   extends MongoProxy["); a(def.name); a("VO] with "); a(def.name); a("VOProxy\n  {\n");
				a('    conn = if (connection != null) connection else MongoConnection();\n');
				a('    db   = if (database   != null) database   else "'); a(collectionName); a('"\n');
				a('    coll = if (collection != null) collection else "'); a(def.fullName.substr(moduleFullName.length + 1).split('.').join('_')); a('"\n\n');
				a('    def setValueObject(vo: '); a(def.name); a('VO, dbo: MongoDBObject) : '); a(def.name); a('VO = outer.setValueObject(vo, dbo);\n');
				a('    override def asObject(dbo: MongoDBObject) : '); a(def.name); a('VO = setValueObject(null.asInstanceOf['); a(def.name); a('VO], dbo);\n');
				a('    override def asDBObject(vo:'); a(def.name); a('VO): DBObject = outer.asDBObject(vo);\n');
			a("  }\n");
		} // end if (def.settings.mongo_proxied)
		a("}\n"); // end Component trait
		
		// XML mapping
		genXMLComponent(def, idProperty);
		
//		if (def.options.length > 0)
//			trace(def.options.first().toString());
	}
	
	
	static function bitmask(numBits:Int, offset:Int=0)
	{
		var mask = 0;
		for (bit in 0 ... numBits) {
			mask |= 1 << (bit + offset);
		}
		return "0x" + StringTools.hex(mask, 4);
	}
	
	
	private function genSerialization(def:ClassDef)
	{	
		new ScalaMessagePacking(code, def).genSerialization();
	}
	
	
	function addPropnameCase(p:Property) {
		a('      case "'); a(p.name); a('" => ');
	}
	function addVOGetterCase(p:Property) {
		addPropnameCase(p); a('vo.'); a(quote(p.name));
	}
	
	function writeLiteral(type:PType, val:Dynamic) switch (type)
	{
		case Tbool(_), Tinteger(_,_,_), Tdecimal(_,_,_):
			a(Std.string(val));
		
		case TfileRef:
			ac('"'.code); a(Std.string(val)); ac('"'.code);
		
		case Tstring:
			ac('"'.code); a(Std.string(val)); ac('"'.code);
		
		case Turi:
			ac('"'.code); a(Std.string(val)); ac('"'.code);
		
		case Tdate, Tdatetime, TuniqueID, Temail:
			ac('"'.code); a(Std.string(val)); ac('"'.code);
		
		case Tcolor:
			if (Std.is(val, String)) {
				ac('"'.code); a(Std.string(val)); ac('"'.code);
			}
			else
				StringTools.hex(val, 6);
		
		case TenumConverter(enums):
			throw "Unsupported value literal";
		
		case Tdef(_), Tinterval, Tarray(_,_,_):
			throw "Unsupported value literal: "+type;
	}
	
	function getSimpleValue(t:PType, path:String) return switch(t) {
		case Tdef(ptypedef):		switch (ptypedef) {
			case Tenum(def):		path;
			default:				path;
		}
		case Turi, Temail, TuniqueID, TfileRef, Tdate, Tdatetime:
			path+".toString";
		case Tstring:				path;
		case Tinteger(_,_,_):		path;
		case Tdecimal(_,_,_):		path;
		case Tbool(_):				path;
		case Tcolor:				path;
		
		case Tinterval:				throw t;
		case Tarray(innerT,_,_):	throw t;
		case TenumConverter(prop):	throw t;
	}
	
	function genNamedSetKeyMatcher(def: NamedSetDef, wildcardMethod:String, action:Int->Property->String)
	{
		if (def.keys.length == 1)
		{
			var k = def.keys[0];
			a(getSimpleValue(k.prop.type, "item." + k.path)); a(" match {");
			
			for (i in 0 ... def.propertiesSorted.length)
			{
				var p = def.propertiesSorted[i];
				a("\n    case "); writeLiteral(k.prop.type, def.getValueByPath(p.defaultValue, k.path)); a(" => "); a(action(i,p));
			}
		}
		else
		{
			a("(");
			for (i in 0 ... def.keys.length) {
				var k = def.keys[i];
				a(getSimpleValue(k.prop.type, "item." + k.path));
				if (i+1 != def.keys.length) a(", ");
			}
			a(") match {");
			
			for (i in 0 ... def.propertiesSorted.length)
			{
				var p = def.propertiesSorted[i];
				a("\n    case (");
				
				var firstKey = true;
				for (k in def.keys)
				{
					if (!firstKey) a(", ");
					else firstKey = false;
					
					writeLiteral(k.prop.type, def.getValueByPath(p.defaultValue, k.path));
				}
				
				a(") => "); a(action(i,p));
			}
		}
		a("\n    case _ => "); a(wildcardMethod); a("(item)\n");
	}
	
	function genNamedSetDefMethods(def: NamedSetDef)
	{
		var type = getType(def.baseType);
		
		a("\n  override def foreach[U](f: "); a(type.name); a(" => U) {");
		for (i in 0 ... def.propertiesSorted.length) {
			var p = def.propertiesSorted[i];
			a("\n    if ($"); a(p.name); a(" != null && fieldIsSet_?("); a(i+")) f($"); a(p.name); a(");");
		}
		if (def.keys.length > 0)
			a("\n    super.foreach(f);");
		a("\n  }\n");
		
		if (def.keys.length == 0) return; // No keys, no way to map...
		
//		a("\n  def this$ = "); a(def.name); a("VO.asInstanceOf[VOCompanion[org.valueobjects.traits.NamedSet["); a(type.name); a("]]];");
		a("\n  override def clear() { "); a(def.name); a("VO.clear(this); super.clear(); }\n");
		a("\n  override def empty: "); a(def.name); a("VO = new "); a(def.name); a("VO;\n");
//		a("\n  override def clone(): this.type = new "); a(def.name); a("VO ++= this;\n");
//		a("\n  override def companion() = "); a(def.name); a("VO;\n");
		
		
		var cl:ClassDef = switch (def.baseType)
		{
			case Tdef(tdef): switch(tdef) {
				case Tclass(cl): cl;
				default: null;
			}				
			default: null;
		}
		if (cl == null) throw def; // Not a set of VO's, so we're done.
		
		a("\n  final override def containsEntry(item:"); a(type.name); a(") = ");
		genNamedSetKeyMatcher(def, "super.containsEntry", function(i,p) return "$"+ p.name +" != null && fieldIsSet_?("+i+");");
		a("  }\n");
		
		a("\n  final override def addEntry(item:"); a(type.name); a(") = {");
		genNamedSetKeyMatcher(def, "super.addEntry", function(i,p) return "this."+quote(p.name)+" = item;");
		a("  }; true; }\n");
		
		a("\n  final override def removeEntry(item:"); a(type.name); a(") = ");
		genNamedSetKeyMatcher(def, "super.removeEntry", function(i,p) return "val old = $"+ p.name +"; if (old != null && fieldIsSet_?("+i+")) Some(old) else None;");
		a("  }\n");
		
		a("}\n");
		
		a("\ntrait "); a(def.name); a("VOXMLComponent extends XMLComponent\n{");
		a("\n  this: "); a(cl.fullName); a("VOXMLComponent =>\n");
		
		a('\n  def setValueObject(valueobject: '); a(def.name); a('VO, xml: NodeSeq) : '); a(def.name); a('VO = ');
		a("\n  {");
		a("\n    val vo = if (valueobject != null) valueobject else new "); a(def.name); a("VO;");
		a("\n    for (xml <- xml) for (node <- xml.child) if (node.isInstanceOf[scala.xml.Elem]) vo.add(setValueObject(new "); a(cl.fullName); a("VO, node));");
		a("\n    vo");
		a("\n  }");
		
		a("\n  def toXML(vo:"); a(def.name); a("VO): NodeSeq = vo.iterator map(toXML(_)) reduceLeft { (a:NodeSeq, b:NodeSeq) => a union b };\n");
		
/*		a("\n  override def get(key: String): Option["); a(type.name); a("] = {");
		for (i in 0 ... def.propertiesSorted)
		{
			var p = def.propertiesSorted[i];
			
			a("\n    if (fieldIsSet_?("+i+")) "); a("this."); a(quote(p.name));
		}
		a("\n    ");
		
/*		
		To implement a concrete map, you need to provide implementations of the following methods:
		      def get(key: A): Option[B]
		      def iterator: Iterator[(A, B)]
		      def + [B1 >: B](kv: (A, B1)): This
		      def -(key: A): This

		If you wish that methods like take, drop, filter also return the same kind of map you should also override:
		      def empty: This

		It is also good idea to override methods foreach and size for efficiency.
		
		a("\n  def get(key: String): Option["); a(type); a("] = ");
		a("\n  def iterator: Iterator[(String, "); a(type); a(")] = ");
		a("\n  def + [B1 >: B](kv: (A, B1)): This = ");
		a("\n  def -(key: A): This = ");
*/	}
	
	function addMongoComponentDependencies(def: ClassDef, subtypes: List<ClassDef>)
	{
		var dependencies = new Hash<Bool>();
		var hasDependencies = false;
		
		var clname;
		for (p in def.propertiesSorted) if (!isRefArray(p) && needsMongoHelperClass(p.type) && (clname = className(p.type)) != def.fullName)
		{
			hasDependencies = true;
			dependencies.set(clname, true);
		}
		
		if (def.settings.mongo_proxied != none) for (cl in def.implementedBy)
		{
			hasDependencies = true;
			dependencies.set(cl.fullName, true);
		}
		
		if (def.superClass != null)
		{
			hasDependencies = true;
			dependencies.set(def.superClass.fullName, true);
		}
		
		for (t in subtypes) {
			hasDependencies = true;
			dependencies.set(t.fullName, true);
		}
		
		if (!hasDependencies) return; // Nothing to do
		addComponentDependencies(code, dependencies, "VOMongoComponent");
	}
	
	static public function addComponentDependencies(code:StringBuf, dependencies:Hash<Bool>, suffix:String)
	{
		var a = code.add;
		var first = true;
		
		for (clname in dependencies.keys())
		{
			a("\n  ");
			if (first) {
				first = false;
				a("this: ");
			}
			else {
				a("with  ");
			}
			a(clname); a(suffix);
		}
		if (!first) a(" =>\n");
	}
	
	function addLowerCaseFirst(str:String)
	{
		code.addChar(str.charAt(0).toLowerCase().charCodeAt(0));
		code.addSub(str, 1);
	}
	
	function className(t:PType) return Util.unpackPTypedef(Util.getPTypedef(t)).fullName
	
	static function propertyName(p:Property) return quote(p.name)
	static public function quote(name:String) return switch (name) {
		case "abstract": "`abstract`";
		case "type": "`type`";
		default: name;
	}
	
	function writeVarGetter(p:Property)
	{
		a("\n  ");
		
		var propName = propertyName(p);
		
		// Storage
		a("/*@field*/ protected[this] var $"); a(p.name); a(": ");
		var tdef = getPropertyTypename(p);
		a(tdef.name);
		a(" = "); a((tdef.defaultValue != null)? tdef.defaultValue : nilValue(p.type));
		
		// Getter
		a("\n  final def "); a(propName); a(" : "); a(tdef.name); a(" = ");
		switch (p.type)
		{
			case Tdef(cl): switch (cl) {
				case Tclass(cl):
					var vo = cl.fullName + "VO";
					add_ifVarNotNull(p.name, (!p.hasOption(mongo_reference))? "new " + vo : "new Ref[" + vo +"](null)");
				
				case Tenum(e):
					add_ifVarNotNull(p.name, e.fullName + ".Null");
			}
			
			case Tarray(innerT,_,_):
				add_ifVarNotNull(p.name, (p.hasOption(mongo_reference)? "RefArray[" : "Array[") + getType(innerT).name +"]()");
			
			case Tstring:
				add_ifVarNotNull(p.name, '""');
			
			case Tdate, Tdatetime, Tinterval, Tcolor, Temail, Turi, TuniqueID, TfileRef, Tinteger(_,_,_), Tdecimal(_,_,_), Tbool(_):
				ac('$'.code); a(p.name);
			
			case TenumConverter(_):		throw p;
		}
	}
	
	function writeSetter(i:Int, p:Property)
	{
		var tdef = getPropertyTypename(p);
		var bit = (1 << this.currentFieldBitNum);
		
		// Setter
		a("\n  final def "); a(p.name); a("_=(v:"); a(tdef.name); a(") : Unit = { ");
		
		switch (p.type) {
			case Tdef(_), Tarray(_,_,_): // Don't set any bits
			default:
				var nilChecked = false;
				if (nilValue(p.type) == "null")
				{
					nilChecked = true;
					a("if (");
					if (p.type == Tstring) a("!v.isEmpty");
					else {
						a("v != "); a(nilValue(p.type));
					}
				 	a(") ");
				}
				a("$fieldsSet |= 0x"); a(StringTools.hex(bit));
				if (nilChecked) {
					a("; else $fieldsSet &= ~0x"); a(StringTools.hex(bit));
				}
				a("; ");
		}
		a("$"); a(p.name); a(" = v } ");
		
		if (p.hasOption(mongo_reference))
		{
			var clname = getType(p.type).name;
			a("\n  final def "); a(p.name); a("_=(v:"); a(clname); a(") : Unit = this."); a(quote(p.name));
			switch (p.type) {
				case Tarray(innerType, _,_):
					var innerName = getType(innerType).name;
					a(" = new RefArray["); a(innerName); a("](v.map("); a(innerName); a(".idValue(_)).toArray, v)");
				default:
					a(" = new Ref["); a(clname); a("]("); a(clname); a(".idValue(v), v)");
			}
			a("\n  final def "); a(p.name); a("_(v:AnyRef) : Unit = ");
			a(quote(p.name));
			a(" = ");
			a(convertFromAnyRefTo(p.type, p.hasOption(mongo_reference)));
			a("(v);\n");
		}
		else
		{
			a("\n  final def "); a(p.name); a("_(v:AnyRef) : Unit = { val value");
			if (Util.isEnum(p.type)) { a(": "); a(getType(p.type).name); }
			a(" = "); a(convertFromAnyRefTo(p.type));
//			if (Util.isEnum(p.type))
//				a("(v.toString).getOrElse(null);");
//			else
				a("(v);");
			
			a(" "); a(quote(p.name)); a(" = value;");
			switch (p.type) {
				case Tdef(_), Tarray(_,_,_): // Don't set any bits
				default:
					a(" if (v == null) "); a("$fieldsSet &= ~0x" + StringTools.hex(bit)); //nilValue(p.type)); ac(")".code);
			}
			a(" }\n");
		}
		
		// Bit number of next flag
		++this.currentFieldBitNum;
	}
	
	function addClassProxy(clname:String, valSuffix:String = "Proxy")
	{
		addLowerCaseFirst(clname.substr(mod.fullName.length + 1).split('.').join('_')); a(valSuffix); a(": VOProxy["); a(clname); a("VO]");
	}
	
	function add_ifVarNotNull(name:String, defaultValue:String)
	{
		a("{ if ($"); a(name); a(" == null) $"); a(name); a(" = "); a(defaultValue); a("; $"); a(name); a(" }");
	}
	
	function commaNewline(comma = true) {
		if (comma) ac(','.code);
		ac('\n'.code);
	}
	
	function addFieldTypeConstructor(t:PType, isRef:Bool) : Void
	{
		a("Type.");
		switch(t)
		{
			case Tdef(cl): switch (cl) {
				case Tclass(cl):	a("Tdef("); a(cl.fullName); a("VO, "); a(Std.string(isRef)); a(")");
				case Tenum(e):		a("Tenum("); a(e.fullName); ac(")".code);
			}
			case Tbool(v):			a("Tbool("); a(Std.string(v)); ac(")".code);
			
			case Tinteger(l,u,s):
				a("Tinteger(");
				if (l != null){											a("min = "); a(Std.string(l)); }
				if (u != null){ if (l != null)				a(", ");	a("max = "); a(Std.string(u)); }
				if (s != null){ if (u != null || l != null)	a(", ");	a("stride = "); a(Std.string(s)); }
				ac(")".code);
			
			case Tdecimal(l,u,s):
				a("Tdecimal(");
				if (l != null){											a("min = "); a(Std.string(l)); }
				if (u != null){ if (l != null)				a(", ");	a("max = "); a(Std.string(u)); }
				if (s != null){ if (u != null || l != null)	a(", ");	a("stride = "); a(Std.string(s)); }
				ac(")".code);
			
			case Tarray(t,l,u):
				a("Tarray("); addFieldTypeConstructor(t,isRef);
				if (l != null || u != null) a(', ');
				if (l != null){							a("min = "); a(Std.string(l)); }
				if (u != null){ if (l != null) a(", ");	a("max = "); a(Std.string(u)); }
				ac(")".code);
			
			default:
				a(Std.string(t));
		}
	}
	
	function writeMongoGetter(p:Property, pathToProp:String)
	{
		a('dbo.getAs['); 
		
		if (isRefArray(p)) switch(p.type) {
			case Tarray(innerType,_,_):
				a("java.util.List[");
				a(Scala.getType(Util.getIDProperty(innerType).type).name);
				a("]");
			
			default: throw "impossible";
		}
		else
			a(mongoType(p.type, p.hasOption(mongo_reference)));
		
		a(']("'); a(p.hasOption(unique)? "_id" : propertyName(p)); a('")');
		a(getType(p.type).mongoOptionGetter);
		a(".map(v => "); a(pathToProp); a(" = ");
		
		if (p.hasOption(mongo_reference)) switch (p.type) {
			case Tarray(innerType,_,_):
				a('RefArray['); a(getType(innerType).name); a('](v)');
			default:
				a('new Ref['); a(getType(p.type).name); a('](');
				a(mongoConversionHelper(Util.getIDProperty(p.type).type, "obj."+quote(p.name)));
				a(')');
		}
		else { // Handle conversions
			a(mongoConversionHelper(p.type, pathToProp));
		}
		a(')\n');
	}
	
	static public function convertFromAnyRefTo(t:PType, ref = false) return switch(t) {
		case Tdef(ptypedef):		switch (ptypedef) {
			case Tenum(def):		def.fullName+".convert";
			default:				"ConvertTo." + (ref? "voRef" : "vo") + "["+ getType(t).name + "]";
		}
		case Tarray(innerT,_,_):	switch (innerT) {
			case Tdef(_):			"ConvertTo.voArray["+getType(innerT).name+"]";
			default:				"ConvertTo.array["+getType(innerT).name+"]";
		}
		case Turi:					"ConvertTo.uri";
		case Temail:				"ConvertTo.email";
		case Tinterval:				"ConvertTo.interval";
		case TuniqueID:				"ConvertTo.uniqueID";
		case TfileRef:				"ConvertTo.fileRef";
		case Tstring:				"ConvertTo.string";
		case Tinteger(_,_,_):		"ConvertTo.integer";
		case Tdecimal(_,_,_):		"ConvertTo.decimal";
		case Tdate:					"ConvertTo.date";
		case Tdatetime:				"ConvertTo.datetime";
		case Tbool(_):				"ConvertTo.boolean";
		case Tcolor:				"ConvertTo.rgba";
		case TenumConverter(prop):	prop.parent.fullName + ".from" + prop.name.substr(2); //"";
	}
	
	function mongoConversionHelper(t:PType, path:String, ?v:String = "v") return switch(t) {
		case Tarray(innerT,_,_):	"JavaConversions.asScalaIterator("+v+".iterator).map(e => "+mongoConversionHelper(innerT, null, "e.asInstanceOf["+ mongoType(innerT,false) +"]") + ").toArray";
		case Turi:					"ConvertTo.uri("+v+")";
		case Temail:				"ConvertTo.email("+v+")";
		case Tinterval:				"ConvertTo.interval("+v+")";
		case Tcolor:				"ConvertTo.rgba("+v+")";
		case TfileRef:				"ConvertTo.fileRef("+v+")";
		
		case Tdef(ptypedef): switch (ptypedef) {
			case Tclass		(def):	"outer.setValueObject("+ (path == null? "null.asInstanceOf["+def.fullName+"VO]" : path) +", "+ v +")"; // "mongo_2_" + def.fullName.split('.').join('_') + ;
			case Tenum		(def):	def.fullName+".convert("+v+")";
		}
		
		case Tdate:					"new org.joda.time.DateMidnight("+v+")";
		case Tdatetime:				"new org.joda.time.DateTime("+v+")";
		
		case TuniqueID, Tstring, Tinteger(_,_,_), Tdecimal(_,_,_), Tbool(_):
			v;
		
		case TenumConverter(_):		throw t; //"";
	}
	
	function needsMongoHelperClass(t:PType) return switch(t) {
		case Tarray(innerT,_,_):	needsMongoHelperClass(innerT);
		case Tdef(t):				switch(t) { case Tenum(_): false; default: true; }
		case Turi,
		 	 Temail,
		 	 Tinterval,
			 TfileRef,
		 	 TuniqueID,
		 	 Tstring,
		 	 Tinteger(_,_,_),
		 	 Tdecimal(_,_,_),
		 	 Tdate,
		 	 Tdatetime,
			 Tcolor,
		 	 Tbool(_):				false; //"Boolean";
		
		case TenumConverter(_):		throw t; //"";
	}
	
	function isBasicMongoType(t:PType) return switch(t) {
		case Tarray(innerT,_,_):	isBasicMongoType(innerT);
		case Tdef(_):				false;
		case Turi:					false;
		case Temail:				false; //"EMail";
		case Tcolor:				false;
		case Tinterval:				false; //"org.joda.time.Interval";
		case TuniqueID:				true;
		case TfileRef:				true;
		case Tstring:				true;
		case Tinteger(_,_,_):		true;
		case Tdecimal(_,_,_):		true;
		case Tbool(v):				true; //"Boolean";
		case Tdate:					false; //"org.joda.time.DateTime";
		case Tdatetime:				false; //"org.joda.time.DateTime";
		case TenumConverter(_):		throw t; //"";
	}
	
	static function mongoType(t:PType, ref:Bool) return switch(t) {
		case Tinterval:				"DBObject";
		case Tdef(d):				
			switch(d) {
				case Tenum(_): "String";
				case Tclass(cl):
					if (ref) {
						var idProp = Util.getIDProperty(t);
						if (idProp == null) throw "No unique id property on: " + cl.fullName;
						mongoType(idProp.type, idProp.hasOption(mongo_reference));
					}
					else "DBObject";
			}
		case Tarray(innerT,_,_):	"BasicDBList";
		case TuniqueID:				"org.bson.types.ObjectId";
		case Tstring:				"String";
		case Tcolor:				"java.lang.Integer";
		case Tinteger(_,_,_):		"java.lang.Integer";
		case Tbool(v):				"java.lang.Boolean";
		case Tdecimal(_,_,_):		"java.lang.Double";
		case Tdate:					"java.util.Date";
		case Tdatetime:				"java.util.Date";
		
		case Turi, Temail, TfileRef:
			"String";
		
		case TenumConverter(_):		throw t; //"";
	}
	
	function arrayInnerType(p:Property) return switch(p.type) {
		case Tarray(innerT,_,_): innerT;
		default: null;
	}
	
	function isRefArray(p:Property) return switch(p.type) {
		case Tarray(_,_,_): p.hasOption(mongo_reference);
		default: false;
	}
	
	function getPropertyTypename(p:Property) return switch(p.type)
	{	
		case Tarray(innerT, _, _):
			if (p.hasOption(mongo_reference)) {name:"RefArray["+getType(innerT).name+"]", defaultValue: null};
			else getType(p.type);
		
		default:
			var type = getType(p.type);
			if (p.hasOption(mongo_reference)) {
			 	type.name = "Ref["+type.name+"]";
			}
			type;
	}
	
	function nilValue(t:PType) return switch(t) {
		case Tstring, Turi, TuniqueID, Tinterval, Tdate, Tdatetime, Temail, Tdef(_), Tarray(_,_,_), Tcolor, TfileRef:
			"null";
		
		case Tinteger(_,_,_):		"0";
		case Tdecimal(_,_,_):		"Double.NaN";
		case Tbool(v):				Std.string(v);
		
		case TenumConverter(_):		throw t; //"";
	}
	
	static function getType(t:PType, ?surroundWithType:String) : {name:String, mongoOptionGetter:String, defaultValue:Dynamic}
	{
		var res = {name:null, mongoOptionGetter:"", defaultValue: null};
		res.name = (surroundWithType != null? surroundWithType + "[" : "") +
		  (switch(t) {
			case Tarray(innerT,_,_):	"Array["+ getType(innerT).name +"]";
			case Turi:					"java.net.URI";
			case TuniqueID:				"org.bson.types.ObjectId";
			case TfileRef:				"primevc.types.FileRef";
			case Tstring:				"String";
			case Tinteger(_,_,_):		res.mongoOptionGetter = ".map(ConvertTo.integer(_))";    "Int";
			case Tdecimal(_,_,_):		res.mongoOptionGetter = ".map(ConvertTo.decimal(_))"; "Double";
			case Tbool(v):				res.defaultValue = v; res.mongoOptionGetter = ".map(_.booleanValue)"; "Boolean";
			case TenumConverter(_):		throw t; //"";
			case Temail:				"javax.mail.internet.InternetAddress";
			case Tdate:					"org.joda.time.DateMidnight";
			case Tdatetime:				"org.joda.time.DateTime";
			case Tinterval:				"org.joda.time.Interval";
			case Tcolor:				"primevc.types.RGBA";
		
			case Tdef(ptypedef): switch (ptypedef) {
				case Tclass		(def):	def.fullName + "VO";
				case Tenum		(def):	def.fullName + ".EValue";
			};
		  }) + (surroundWithType != null? "]" : "");
		
		return res;
	}
	
	public function genEnum	(def:EnumDef)	: Void
	{
		shouldWrite = true;
		
		var a = code.add;
		var addConversionParams = function(withVal) {
			for (prop in def.conversions) if (prop.name != "toString") {
//				Assert.that(prop.type == Tstring, Std.string(def));
				a(", ");
				if (withVal) a("val ");
				a(quote(prop.name)); a(":String"); // a(conv); ac('"'.code);
			}
		}
		
		a("\nobject "); a(def.name); a(" extends Enumeration with Enum {\n  ");
		
		var overrideValueOf = null;
		
		a("class EValue(nextId:Int, name:String");
		addConversionParams(true);
		a(") extends Val(nextId, name);\n  ");
		a("def V(name:String");
		addConversionParams(false);
		a(") = new EValue(nextId, name");
		for (prop in def.conversions) if (prop.name != "toString") {
			a(", "); a(quote(prop.name));
		}
		a(");\n");
		
		a("\n  def fromValue(v: Int) : this.EValue = v match {");
		for (e in def.enumerations) if (e.type == null)
		{
			a("\n    case " + e.intValue); a(" => this."); a(e.name);
		}
		a("\n  }\n\n");
		
		a('  val Null = V(""');
		for (prop in def.conversions) if (prop.name != "toString") a(", null");
		a(")\n");
		
		for (e in def.enumerations)
		{
			
			if (e.type != null)
			{
				a('  def '); a(e.name); a('(value:'); a(getType(e.type).name); a(') = new EValue(nextId, "'); a(e.name); ac('"'.code);
				for (key in e.conversions.keys()) if (key != "toString") {
					var conv = e.conversions.get(key);
					a(', "'); a(conv); ac('"'.code);
				}
				a(");\n\n");
				
				overrideValueOf = e;
			}
			else {
				a("  val "); a(e.name); a(' = V("'); a(e.name); ac('"'.code);
				for (prop in def.conversions) if (prop.name != "toString") {
					var conv = e.conversions.get(prop.name);
					a(', "'); a(conv != null? conv : e.name); ac('"'.code);
				}
				a(")\n");
			}
		}
		
  		for (conv in def.conversions)
		{
			a("\n\n  final def from"); a(conv.name.substr(2)); a("(str:String) : "); a(def.fullName); a(".EValue = str match\n  {");
			for (e in conv.enums) if (e != def.catchAll)
			{
				a('\n    case "'); a(e.conversions.get(conv.name)); a('" => '); a(e.name); a(";");
			}
			if (overrideValueOf != null) {
				a("\n    case _ => "); a(overrideValueOf.name); a("(str);");
			}
			else if (conv.name != "toString")
				a("\n    case _ => fromString(str);");
			else
			 	a("\n    case _ => Null");
				
			a("\n  }");
		}
		a("\n}\n");
	}
	
	function genXMLComponent(def:ClassDef, idProperty:Property)
	{
		var map = def.getOptionDef(XMLMapping);
		if (map == null) return;
		
		a("trait "); a(def.name);
		a("VOXMLComponent extends XMLComponent\n{");
		
		var g = new XMLProxyGenerator(code, def, map);
		g.genDependencies();
		g.fromXML();
		g.toXML();
//		g.implicits();
		
		if (idProperty != null)
		{
			a("  trait "); a(def.name); a("VOXMLProxy\n   extends XMLProxy["); a(def.name); a("VO] with "); a(def.name); a("VOProxy {\n");
			a("    def toXML(vo:"); a(def.name); a("VO): NodeSeq = outer.toXML(vo);\n");
			a('    def setValueObject(vo: '); a(def.name); a('VO, xml: NodeSeq) : Option['); a(def.name); a('VO] = outer.setValueObject(vo, xml);\n');
			a("  }\n");
		}
		
		ac('}'.code);
	}
}

class XMLProxyGenerator
{
	var code	: StringBuf;
	var def		: ClassDef;
	var map		: XMLMapping;
	var root	: XMLMapNode;
	var addSuperClassMapping : Bool;
	
	var xmlConverters : Hash<String>;
	var dependencies: Hash<Bool>;
	
	public function new(code:StringBuf, def:ClassDef, map:XMLMapping)
	{
		Assert.that(map != null);
		Assert.that(Std.is(map, XMLMapping), Std.string(map));
		
		this.code = code;
		this.def  = def;
		this.map  = map;
		this.root = map.getMergedMapping();
		
		if (root.children.length == 0) throw "no child?!";
		
		this.xmlConverters = new Hash();
		dependencies = new Hash();
		findDependencies(map.root);
		
		if (def.superClass != null && def.superClass.defaultXMLMap != null && !def.superClass.defaultXMLMap.root.isXMLTypeMap()) {
			addSuperClassMapping = true;
			dependencies.set(def.superClass.fullName, true);
		}
	}
	
	function addDependencyForValue(value) switch (value)
	{
		case XM_children(path, prop),
		 	 XM_child	(path, prop):
			
			var cl = Util.unpackPTypedef(Util.getPTypedef(prop.type));
		/*	if (Std.is(cl, NamedSetDef)) {
				cl = Util.unpackPTypedef(Util.getPTypedef(cast(cl, NamedSetDef).baseType));
			}
		*/	dependencies.set(cl.fullName, true);
		
		case XM_typeMap(map):			for (k in map.keys()) dependencies.set(map.get(k).fullName, true);
		
		default:
	}
	
	function findDependencies(node:XMLMapNode)
	{
		if (node.value != null)
			addDependencyForValue(node.value);
		
		if (node.attributes != null) for (a in node.attributes)
			addDependencyForValue(a);
		
		for (c in node.children)
			findDependencies(c);
	}
	
	public function implicits()
	{
		for (i in xmlConverters) a(i);
	}
	
	public function genDependencies()
	{
		Scala.addComponentDependencies(code, dependencies, "VOXMLComponent");	
	}
	
	public function fromXML()
	{
		a('\n  def setValueObject(valueobject: '); a(def.name); a('VO, xml: NodeSeq) : '); a(def.name); a('VO =');
		
	 	if (gen_fromXMLValueToTypeMapping(map.root))
			return;
		
		a("\n  {");
		a("\n    val vo = if (valueobject != null) valueobject else new "); a(def.name); a("VO;\n");
		if (addSuperClassMapping)
		{
			a("\n    setValueObject(vo.asInstanceOf["); a(def.superClass.fullName); a("VO], xml);");
			// Don't use the merged map, since we can rely on superClass setValueObject calls.
			fromXMLNode(map.root, "vo.", 2);
		}
		else
		{
			fromXMLNode(root, "vo.", 2);
		}
		a("\n    vo");
		a("\n  }\n");
	}
	
	function fromXMLNode(node:XMLMapNode, varPrefix:String, indentLevel:Int)
	{
/*		for (c in node.children) if (isMultiChildXMLMap(c.value)) {
			//TODO: iterables
			ac('\n'.code);
			indent(indentLevel);
			add_fromXMLValue(c.value, varPrefix);
		}
*/		
		#if debug
		a('println("'); for (i in 0 ... indentLevel) ac(' '.code); a(def.fullName); a(': " + xml.headOption.map(_.label).getOrElse("-"))\n');
		#end
		
		// Multiple childnodes mapped props:
		for (child in node.children) if (isMultiChildXMLMap(child.value)) {
	 		indent(indentLevel); a("//  Multi, firstNode: "); a(child.nodeName); a('\n');
			indent(indentLevel);
			add_fromXMLValue("multi", child.value, varPrefix);
			a('\n');
		}
		
		// The rest...
		
		if (node.value != null && node.valuePath != null && !isMultiChildXMLMap(node.value)) {
	 		a('\n');
			indent(indentLevel); a("//  Node value: "); a(node.nodeName); a('\n');
			indent(indentLevel);
			add_fromXMLValue("xml.text", node.value, varPrefix);
		}
		
		if (node.children.length == 1)
		{
			var root = node.children[0];
			
			ac('\n'.code);
			indent(indentLevel); a("//  <"); a(root.nodeName); a('>\n');
			indent(indentLevel);
			if (isChildXMLMap(root.value)) {
				add_fromXMLValue("I#^%@HKJD", root.value, varPrefix);
			}
			else if (!isMultiChildXMLMap(root.value))
			{
				a('xml.headOption map { xml =>\n');
				fromXMLNode(root, varPrefix, indentLevel+1);
				gen_fromNodeAttr(root, varPrefix, indentLevel+1);
				ac('\n'.code);
				indent(indentLevel); a('}\n');
			}
		}
		else if (node.children.length > 1)
		{
			ac('\n'.code);
			indent(indentLevel);
			if (node.nodeName == "")
			 	a('for (xml <- xml) ');
			a('for (xml <- xml.child) if (xml.isInstanceOf[scala.xml.Elem]) {\n');
			
			#if debug
			a('println("'); for (i in 0 ... indentLevel + 1) ac(' '.code); a('" + xml.label)\n');
			#end
			indent(indentLevel+1);	a('xml.label match {');
			
			for (child in node.children) if (!isMultiChildXMLMap(child.value)) {
				ac('\n'.code);
				indent(indentLevel + 2); a('case "'); a(child.nodeName); a('" => ');
				#if debug
				a('println("'); for (i in 0 ... indentLevel + 2) ac(' '.code); a('" + xml.label)\n');
				#end
				fromXMLNode(child, varPrefix, indentLevel+3);
				gen_fromNodeAttr(child, varPrefix, indentLevel+3);
			}
			indent(indentLevel+2); a('case _ =>\n');
			indent(indentLevel+1); a('}\n');
			indent(indentLevel);   a('}');
		}
	}
	
	function gen_fromXMLValueToTypeMapping(node:XMLMapNode) : Bool
	{
		var code_added = false;
		
		// Handle value->type mappings first
		if (node.attributes != null) for (attr in node.attributes.keys()) switch (node.attributes.get(attr))
		{
			case XM_typeMap(map):
				if (code_added) throw "Error: multiple type-maps found";
				
				var matchAdded = false;
				
				for (k in map.keys())
				{
					if (!matchAdded) {
						a(' (xml \\ "@'); a(attr); a('").text match\n  {');
						matchAdded = true;
					}
					
					var clname = map.get(k).fullName;
					a('\n    case "'); a(k); a('" => outer.setValueObject(valueobject match { case v: '); a(clname); a("VO => v; case _ => new "); a(clname); a("VO }, xml);");
					
					code_added = true;
				}
				if (matchAdded) a("\n    case _ => valueobject\n  }\n");
			
			default:
		}
		
		for (child in node.children)
			if (code_added) throw "Error: multiple type-maps found";
			else code_added = gen_fromXMLValueToTypeMapping(child);
		
		return code_added;
	}
	
	function gen_toXMLValueToTypeMapping(node:XMLMapNode) : Bool
	{
		var code_added = false;
		
		// Handle value->type mappings first
		if (node.attributes != null) for (attr in node.attributes.keys()) switch (node.attributes.get(attr))
		{
			case XM_typeMap(map):
				if (code_added) throw "Error: multiple type-maps found";
				
				var added = new Hash<Bool>();
				var clname = null;
				
				a("vo match {");
				for (val in map) if (!added.exists(clname = val.fullName)) {
					a("\n    case vo:"); a(clname); a('VO => toXML(vo)');
					added.set(clname, true);
				}
				a('\n    case _ => null\n  }\n');
				
				code_added = true;
				
			default:
		}
		
		for (child in node.children)
			if (code_added) throw "Error: multiple type-maps found";
			else code_added = gen_toXMLValueToTypeMapping(child);
		
		return code_added;
	}
	
	function gen_fromNodeAttr(node:XMLMapNode, varPrefix:String, indentLevel:Int)
	{
		if (node.attributes != null)
		{
			ac('\n'.code);
			indent(indentLevel); a("for (xml <- xml.attributes) xml.key match\n");
			indent(indentLevel); ac("{".code);
			for (name in node.attributes.keys()) if (matchAttribute(node.attributes.get(name)))
			{
				ac('\n'.code);
				indent(indentLevel+1); a('case "'); a(name); a('" => ');
				add_fromXMLValue("xml.value.text", node.attributes.get(name), varPrefix);
			}
			ac('\n'.code);
			indent(indentLevel+1); a('case _ =>\n');
			indent(indentLevel);   a('}\n');
		}
	}
	
	public function toXML()
	{
		a("\n  def toXML(vo:"); a(def.name); a("VO): NodeSeq = ");
		
		if (gen_toXMLValueToTypeMapping(map.root))
			return;
		
		if (root.children.length == 1)
			gen_toNode(root.children[0]);
		else {
			a("\n  <xml>");
			for (child in root.children) gen_toNode(child, 2);
			a("\n  </xml>.child");
		}
		
		a('\n\n');
	}
	
	function gen_toNode(node:XMLMapNode, indentLevel:Int=1)
	{
		ac('\n'.code);
		indent(indentLevel);
		
		if (hasValue(node) && (isChildXMLMap(node.value) ||isMultiChildXMLMap(node.value)))
		{
			a('{ ');
			addToXMLWithCheckFieldIsSet(node.value, "vo.");
			a(' }');
			return;
		}
		
		ac('<'.code); a(node.nodeName);
	
		var atCount = 0;
	
		if (node.attributes != null) for (name in node.attributes.keys())
		{
			var attr = node.attributes.get(name);
			ac('\n'.code); indent(indentLevel + 1);
			
			// Handle simple strings first
			switch(attr) {
				case XM_empty:
				case XM_String(v):
					ass(name); ac('='.code); ac('"'.code); a(v); ac('"'.code);
			
				default:
					ass(name); a('={');
					addToXMLWithCheckFieldIsSet(attr, "vo.");
					ac('}'.code);
			}
		}
	
		if (!hasValue(node) && node.children.length == 0) {
			a("/>");
			return; // done
		}
	
		
		// Value or children
		a('>');
		
		if (hasValue(node))
		{
			Assert.that(node.children.length == 0);
			
			var brackets = false;
			
			switch(node.value) {
				case XM_empty:
				case XM_String(v): a(v);
				default:
					brackets = true;
			}
			
			if (brackets)
			{
				a('{ ');
				addToXMLWithCheckFieldIsSet(node.value, "vo.");
				a(' }');
			}
		}
		
		if (node.children.length > 0)
		{
		 	for (child in node.children) if (isMultiChildXMLMap(child.value)) {
				ac('\n'.code);
				indent(indentLevel+1); a("{ "); addToXMLWithCheckFieldIsSet(child.value, "vo."); a(" }");
			} else {
				gen_toNode(child, indentLevel + 1);
			}
			
			ac('\n'.code); indent(indentLevel);
		}
		a('</'); a(node.nodeName); a('>');
	}
	
	inline function addPathEscaped(path:String)
	{
		var pieces = path.split('.');
		var i = 0;
		for (s in pieces) {
			a(Scala.quote(s));
			if (++i != pieces.length) ac('.'.code);
		}
	}
	
	function add_ifStringSet(varName:String) {
		a("val s = "); a(varName); a("; if (s.length != 0) ");
	}
	
	function add_setVarFromString(varName:String, varPrefix:String, setterPath:String, type:PType, converterPrefix:String, format:String)
	{
		add_ifStringSet(varName);
		add_setVar(varPrefix, setterPath, type);
		
//		if (format != null) {
			a(converterPrefix);
			add_conversionFromStringFunction(type);
			ac("(".code); a("s"); if (format != null) { a(', "'); a(format); ac('"'.code); } ac(")".code);
//		}
//		else {
//			a("s");
//		}
//		if (Util.isEnum(type)) {
//			a(".getOrElse(null)");
//		}
	}
	
	function add_setVar(varPrefix:String, setterPath:String, type:PType)
	{
		a(varPrefix);
		switch (type) {
			case TenumConverter(_):
				addPathEscaped(setterPath.substr(0, setterPath.lastIndexOf('.'))); // strip enum converter property
			default:
				addPathEscaped(setterPath);
		}
		a(" = ");
	}
	
	function add_conversionFromStringFunction(type) switch (type)
	{
		case Tstring:
		default:
			a(Scala.convertFromAnyRefTo(type));
	}
	
	function matchAttribute(v:XMLMapValue) return switch (v) {
		case XM_empty, XM_String(_), XM_typeMap(_):
		 	false;
		default: true;
	}
	
	function add_fromXMLValue(varName:String, v:XMLMapValue, varPrefix:String, converterPrefix:String = "")
	{
		// Handle expressions
		switch(v)
		{
			case XM_empty, XM_String(_), XM_typeMap(_):
				// Not a value type
				
			case XM_binding		(path, prop), XM_toInt(path, prop):
				add_setVarFromString(varName, varPrefix, path, prop.type, converterPrefix, null);
			
			case XM_not			(v):
				add_fromXMLValue(varName, v, varPrefix, converterPrefix + "!");
			
			case XM_format		(path, prop, format):
				add_setVarFromString(varName, varPrefix, path, prop.type, converterPrefix, format);
			
			case XM_join		(path, prop, seperator):
				add_ifStringSet(varName);
				add_setVar(varPrefix, path, prop.type);
				a(converterPrefix);
				add_conversionFromStringFunction(prop.type);
				a('('); a(varName); a('.split("'); a(seperator); a('"))');
				
			case XM_concat		(values):
				throw "not implemented";

			case XM_children	(path, prop),
			 	 XM_child		(path, prop):
				
				
				var clname = Util.unpackPTypedef(Util.getPTypedef(prop.type)).fullName;
				
				if (Util.isPTypeIterable(prop.type)) {
					a("val tmp_"); a(path); a(" = ");
					a("xml.child.iterator.filter(_.isInstanceOf[scala.xml.Elem]) map { node => ");
					a("outer.setValueObject(new "); a(clname); a("VO, node) ");
					a("} filterNot(_.empty_?) toArray;");
					a("  if (tmp_"); a(path); a(".length > 0) ");
					add_setVar(varPrefix, path, prop.type);
					a("tmp_"); a(path);
				}
				else {
					a("outer.setValueObject("); a(varPrefix); a(path); a(", xml)");
				}
		}
	}
	
	function isMultiChildXMLMap(value:XMLMapValue)
	{
		return value != null && switch (value)
		{
			case XM_children(_,_): true;
			default: false;
		}
	}
	
	function isChildXMLMap(value:XMLMapValue)
	{
		return value != null && switch (value)
		{
			case XM_child(_,_): true;
			default: false;
		}
	}
	
	function addCheckFieldIsSet(v:XMLMapValue, pathPrefix) switch (v)
	{
		// Handle fieldIsSet_?
		case XM_binding(path,prop),
		 	 XM_toInt(path,prop),
		 	 XM_format(path,prop,_),
			 XM_child(path,prop),
		 	 XM_children(path,prop),
		 	 XM_join(path,prop,_):
			
			if (Util.isEnum(prop.type))
				return false;
			
			var objPathEnd = path.lastIndexOf('.');
			
			var fieldIndex = -1;
			for (i in 0 ... prop.parent.propertiesSorted.length)
			{
				var p = prop.parent.propertiesSorted[i];
				if (p.name != prop.name) continue;
				fieldIndex = i;
				break;
			}
			
			if (fieldIndex == -1) throw "Property index not found for pathPrefix: "+pathPrefix+", path: "+path+", substr: "+path.substr(0, objPathEnd)+" prop named: "+prop.name+" in object: "+prop.parent.fullName;
			
			a("if ("); a(pathPrefix);
			if (objPathEnd != -1) {
				a(Scala.quote(path.substr(0, objPathEnd))); ac('.'.code);
			}
			a("fieldIsSet_?("); a(fieldIndex+" /*"); a(prop.parent.fullName); a(" */)) ");
			
			return true;
		
		case XM_not(v):
			return addCheckFieldIsSet(v, pathPrefix);
		
		default:
			return false;
	}
	
	function addToXMLWithCheckFieldIsSet(v:XMLMapValue, pathPrefix)
	{
		if (addCheckFieldIsSet(v, pathPrefix)) {
			addToXMLValue(v, pathPrefix);
			a('; else null'); // Check if else null will not give problems with the PHP cms
		}
		else
			addToXMLValue(v, pathPrefix);
	}
	
	function addToXMLValue(v:XMLMapValue, pathPrefix) switch (v)
	{
		case XM_typeMap(_), XM_String(_): throw "Should have been handled already...";
		
		case XM_binding		(path,prop):
			addConvertedToString(pathPrefix + path, prop.type);
		
		case XM_toInt		(p,v):
			a("new scala.xml.Unparsed(("); addIntString(pathPrefix + p, v.type); a(").toString)");
		
		case XM_not			(v): 
			addToXMLValue(v, "!"+pathPrefix);
		
		case XM_format		(path,prop,format):
			a("ConvertTo.string(");
			addPathEscaped(pathPrefix + path);
			a(",\"");
			a(format);
			a("\")");
		
		case XM_join		(path,val,seperator):
			var a = a;
			switch (val.type) {
				default:
					throw "Only array joins are supported. v="+v+", pathPrefix="+pathPrefix;
				
				case Tarray(elemT, min, max):
					switch(elemT) {
						case Tstring:
						default:
							throw "Only Array<String> joins are supported.";
					}
					a(pathPrefix); addPathEscaped(path); a('.mkString("'); a(seperator); a('")');
			}
		
		case XM_concat		(values):
			for (i in 0 ... values.length) {
				addToXMLValue(values[i], pathPrefix);
				if (i <= values.length - 2) a(" + ");
			}
		
			trace(code.toString());
			//throw "not implemented";
		
		case XM_empty:								throw "Empty attribute? ";
		
		case XM_children	(path,from), XM_child(path,from):
			add_toXMLChildren(pathPrefix + path, from.type);
	}
	
	function add_toXMLChildren(path, type) switch(type)
	{
		case Tdef(t):
			var clname = Util.unpackPTypedef(t).fullName;
			a("toXML("); addPathEscaped(path); a(")");
		
		default:
			switch(type)
			{
				case Tarray(t,_,_):
					addPathEscaped(path);
				 	a(".iterator.map({ i => "); add_toXMLChildren("i", t); a(" })"); // _.toXML())");
				
				default: throw "impossible";
			}
	}
	
	function addConvertedToString(path, type) switch (type)
	{
		case Tstring:
			addPathEscaped(path);
			
		case Tbool(_), Tinteger(_,_,_):
			a("new scala.xml.Unparsed(("); addPathEscaped(path); a(").toString)");
			
		default:
			a("ConvertTo.string("); addPathEscaped(path); ac(")".code);
	}
	
	inline function indent(times:Int) for (i in 0 ... times) a("  ")
	
	function addIntString(path, type) switch(type)
	{
		case Tbool(val):				a("if ("); addPathEscaped(path); a(") 1 else 0");
		case Tinteger(min,max,stride):	addPathEscaped(path);
		case Tdecimal(min,max,stride):	addPathEscaped(path); a(".toInt");
		case Tstring:					addPathEscaped(path); throw "Int String? "+path+" : "+type;
		case Tcolor:					addPathEscaped(path); a(".toInt");
		case Tdate:						addPathEscaped(path); a(".getMillis()");
		case Tdatetime:					addPathEscaped(path); a(".getMillis()");
		
		default: throw "not implemented for type: "+type;
	}
	
	inline function hasValue(node) return node.value != null && node.value != XM_empty
	
	// Adds space then String :-)
	inline function ass(s:String) {
		ac(" ".code);
		a(s);
	}
	
	inline function a(str) code.add(str)
	inline function ac(ch) code.addChar(ch)
}

class ScalaMessagePacking extends MessagePacking
{
	override private function expr_incrementMixinCount()	return "mixin += 1"
	override private function a_return() a("return")
	override private function a_not0(v:String) {
		a(v); a(" != 0");
	}
	
	override private function a_is0(v:String) {
		a("("); a(v); a(") == 0");
	}
	
	override private function a_packVOHeaderCallStart() {
		a("\n\t\to.packValueObjectHeader("); a(Std.string(def.index)); a(", ");
	}
	
	override private function a_msgpackVOCallStart(t : TypeDefinition) {
		a("\n\t\t\t"); addFullName(t); a(".msgpack_packVO(o, obj, ");
	}
	
	override private function a_assert(v:String) {
		a("require("); a(v); a(");");
	}
	override private function a_writeByte(byte:String) {
		a("o.writeByte("); a(byte); a(");");
	}
	override private function endPackerFunction() {
		a("\n\t}\n");
	}
	
	override private function addPropertyPackerCall(path:String, pType:PType, bindable:Bool)
	{
		if (path.indexOf("obj.") == 0) {
			path = "obj." + Scala.quote(path.substr(4));
		}
		
		switch (pType)
		{
			case Tdef(_), Tbool(_), Tinteger(_,_,_), Tdecimal(_,_,_), Tstring, Tdate, Tdatetime, Tinterval, Turi, TuniqueID, Temail, Tcolor, TfileRef:
				a('o.pack('); a(path); ac(")".code);
			
			case Tarray(type, min, max):
				a("{");
				a("\n\t\t\t\tval arr = "); a(path); ac(";".code);
				a("\n\t\t\t\to.packArray(arr.length);");
				a("\n\t\t\t\tfor (item <- arr) "); addPropertyPackerCall("item", type, false); ac(";".code);
				a("\n\t\t\t}");
			
			
			case TenumConverter(_):	throw "Not implemented";
		}
	}
	
	override private function definePackerFunction()
	{
		a("\n\tdef msgpack_packVO(o : VOPacker, obj : "); a(def.name); a(", flagsToPack : Int)\n\t{"); //"); a(Module.pkgRoots.first().name); a("]
		a("\n		require(o != null && obj != null);");
		a("\n		");
		a("\n		var propertyBits = flagsToPack;");
	}
	
	var fieldIndexOffset : IntHash<Bool>;
	
	override private function genDeSerialization(lastProp)
	{
		fieldIndexOffset = new IntHash();
		
		a("\n  val TypeID = "); a(Std.string(def.index));
		a("\n  def fieldIndexOffset(typeID: Int) = typeID match {");
		genFieldOffsetCases(def);
		a("\n  }\n");
	}
	
	private function genFieldOffsetCases(t:TypeDefinition)
	{
		if (t.is(ClassDef)) {
			for (s in t.as(ClassDef).supertypes) genFieldOffsetCases(s);
		}
		
		if (!fieldIndexOffset.exists(t.index)) {
			fieldIndexOffset.set(t.index, true);
			a("\n    case "); a(Std.string(t.index)); a(" => ");
		
			var offset = 0; for (p in def.propertiesSorted) if (p.definedIn != t) ++offset; else break;
			a(offset + ";"); a(" // "); a(t.fullName);
		}
	}
	
	override private function a_unpackProperty(p:Property)
	{
		a(p.name); a(" = "); a("input.unpack();");
	}
}
